//
// This unit is part of the DGLEngine Project, http://glscene.org
//
{: XOpenGL<p>

   "Alternate" OpenGL functions to handle multi-texturing.<p>

   Using this functions allows specifying none/one/multiple ARB multi-texture
   coordinates with standard texture specification call.<p>

   Before using any of the xglTexCoordXxxx fonctions, call one of the
   xglMapTexCoordToXxxx functions to establish the redirectors.<p>


  <b>Historique : </b><font size=-1><ul>
  <li>21/12/15 - JD -  Imported and Updated From GLScene
  </ul></font>

  @STATUS : UPDATE INCOMPLETE - This unit it is essential, can we discard it ?????
  @TODO : Set properly MutiTexCoord Function by adding TARGET:GLEnum parameter
          Change glEnableClientState(aArray) and glDisabledClientState(aArray)
          by glEnableClientStateIndexedEXT(aArray,Idx) and glEnableClientStateIndexedEXT(Idx) ?????
          But how to manage the Idx ????? no idea at this time
}
unit DGLXOpenGL;

interface

{$I DGLEngine.inc}

uses
  dglOpenGL,
  DGLTypes,
  DGLContext;

Type

  TGLMultitextureCoordinator = class(TAbstractMultitextureCoordinator)
  private
    FMapTexCoordMode: TMapTexCoordMode;
    FSecondTextureUnitForbidden: Boolean;

    FUpdCount: Integer;
    FUpdNewMode: TMapTexCoordMode;
    FStateStack: array of TMapTexCoordMode;
    FComplexMapping: array of Cardinal;
    FComplexMappingN: Integer;
  public
//    // Explicit texture coordinates specification
    TexCoord2f: procedure(s, t: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexCoord2fv: procedure(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexCoord3f: procedure(s, t, r: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexCoord3fv: procedure(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexCoord4f: procedure(s, t, r, q: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexCoord4fv: procedure(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}

    // TexGen texture coordinates specification
    TexGenf: procedure(coord, pname: TGLEnum; param: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexGenfv: procedure(coord, pname: TGLEnum; params: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexGeni: procedure(coord, pname: TGLEnum; param: TGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    TexGeniv: procedure(coord, pname: TGLEnum; params: PGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}

    // Vertex Arrays texture coordinates specification
    TexCoordPointer: procedure(size: TGLint; atype: TGLEnum; stride: TGLsizei;
      data: pointer);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    EnableClientState: procedure(aarray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    DisableClientState: procedure(aarray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}

    // Misc
    Enable: procedure(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
    Disable: procedure(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}

    constructor Create(AOwner: TDGLContext); override;

    {: TexCoord functions will be ignored. }
    procedure MapTexCoordToNull;
    {: TexCoord functions will define the main texture coordinates. }
    procedure MapTexCoordToMain;
    {: TexCoord functions will define the second texture unit coordinates. }
    procedure MapTexCoordToSecond;
    {: TexCoord functions will define the two first texture units coordinates. }
    procedure MapTexCoordToDual;
    {: TexCoord functions will define the specified texture units coordinates. }
    procedure MapTexCoordToArbitrary(const units: array of Cardinal); overload;
    procedure MapTexCoordToArbitrary(const bitWiseUnits: Cardinal); overload;
    procedure MapTexCoordToArbitraryAdd(const bitWiseUnits: Cardinal);

    {: Defers Map calls execution until EndUpdate is met.<p>
       Calls to Begin/EndUpdate may be nested. }
    procedure BeginUpdate;
    {: Applies Map calls if there were any since BeginUpdate was invoked.<p>
       Calls to Begin/EndUpdate may be nested. }
    procedure EndUpdate;

    {: Saves XOpenGL State on the stack. }
    procedure PushState;
    {: Restores XOpenGL State from the stack. }
    procedure PopState;

    {: Whenever called, 2nd texture units changes will be forbidden to .<p>
       Use this function when you're using the 2nd texture unit for your own
       purposes and don't want XOpenGL to alter it. }
    procedure ForbidSecondTextureUnit;
    {: Allow XOpenGL to use the second texture unit again. }
    procedure AllowSecondTextureUnit;
    {: Returns the complex mapping in bitwise form. }
    function GetBitWiseMapping: Cardinal;

    property MapTexCoordMode: TMapTexCoordMode read FMapTexCoordMode write FMapTexCoordMode;
    property SecondTextureUnitForbidden: Boolean read FSecondTextureUnitForbidden;
  end;

function xgl(): TGLMultitextureCoordinator;

// ------------------------------------------------------------------
// ------------------------------------------------------------------
// ------------------------------------------------------------------
implementation
// ------------------------------------------------------------------
// ------------------------------------------------------------------
// ------------------------------------------------------------------

{$IFNDEF GLS_MULTITHREAD}
var
{$ELSE}
threadvar
{$ENDIF}
  vMTC : TGLMultitextureCoordinator;

function xgl(): TGLMultitextureCoordinator;
var
  RC: TDGLContext;
begin
  RC := SafeCurrentDGLContext;
  if not Assigned(vMTC) or (vMTC.FOwner <> RC) then
  begin
    vMTC := TGLMultitextureCoordinator(RC.MultitextureCoordinator);
  end;
  Result := vMTC;
end;

  // ------------------------------------------------------------------
  // Multitexturing coordinates duplication functions
  // ------------------------------------------------------------------

  // --------- Complex (arbitrary) mapping

procedure TexCoord2f_Arbitrary(s, t: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord2fARB(xgl.FComplexMapping[i], s, t);
end;

procedure TexCoord2fv_Arbitrary(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord2fvARB(xgl.FComplexMapping[i], v);
end;

procedure TexCoord3f_Arbitrary(s, t, r: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord3fARB(xgl.FComplexMapping[i], s, t, r);
end;

procedure TexCoord3fv_Arbitrary(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord3fvARB(xgl.FComplexMapping[i], v);
end;

procedure TexCoord4f_Arbitrary(s, t, r, q: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord4fARB(xgl.FComplexMapping[i], s, t, r, q);
end;

procedure TexCoord4fv_Arbitrary(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
    glMultiTexCoord4fvARB(xgl.FComplexMapping[i], v);
end;

procedure TexGenf_Arbitrary(coord, pname: TGLEnum; param: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glMultiTexGenfEXT(coord, pname,0, param);
  end;
end;

procedure TexGenfv_Arbitrary(coord, pname: TGLEnum; params: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glMultiTexGenfvEXT(coord, pname,0, params);
  end;
end;

procedure TexGeni_Arbitrary(coord, pname: TGLEnum; param: TGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glMultiTexGeniEXT(coord, pname, 0, param);
  end;
end;

procedure TexGeniv_Arbitrary(coord, pname: TGLEnum; params: PGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glMultiTexGenivEXT(coord, pname, params);
  end;
end;

procedure Enable_Arbitrary(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glEnable(cap);
  end;
end;

procedure Disable_Arbitrary(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    CurrenTDGLContext.GLStates.ActiveTexture := xgl.FComplexMapping[i];
    glDisable(cap);
  end;
end;

procedure TexCoordPointer_Arbitrary(size: TGLint; atype: TGLEnum; stride:
  TGLsizei; data: pointer);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    glClientActiveTextureARB(xgl.FComplexMapping[i]);
    glTexCoordPointerEXT(size, atype, stride, data);
  end;
end;

procedure EnableClientState_Arbitrary(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    glClientActiveTextureARB(xgl.FComplexMapping[i]);
    //glEnableClientState(aArray);
  end;
end;

procedure DisableClientState_Arbitrary(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
var
  i: Integer;
begin
  for i := 0 to xgl.FComplexMappingN do
  begin
    glClientActiveTextureARB(xgl.FComplexMapping[i]);
    //glDisableClientState(aArray);
  end;
end;

// --------- Second unit Texturing

procedure TexCoord2f_Second(s, t: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord2fARB(GL_TEXTURE1, s, t);
end;

procedure TexCoord2fv_Second(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord2fvARB(GL_TEXTURE1, v);
end;

procedure TexCoord3f_Second(s, t, r: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord3fARB(GL_TEXTURE1, s, t, r);
end;

procedure TexCoord3fv_Second(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord3fvARB(GL_TEXTURE1, v);
end;

procedure TexCoord4f_Second(s, t, r, q: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord4fARB(GL_TEXTURE1, s, t, r, q);
end;

procedure TexCoord4fv_Second(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord4fvARB(GL_TEXTURE1, v);
end;

procedure TexGenf_Second(coord, pname: TGLEnum; param: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glMultiTexGenfEXT(coord, pname, param);
end;

procedure TexGenfv_Second(coord, pname: TGLEnum; params: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glMultiTexGenfvEXT(coord, pname, params);
end;

procedure TexGeni_Second(coord, pname: TGLEnum; param: TGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glMultiTexGeniEXT(coord, pname, param);
end;

procedure TexGeniv_Second(coord, pname: TGLEnum; params: PGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glMultiTexGenivEXT(coord, pname, params);
end;

procedure Enable_Second(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glEnable(cap);
end;

procedure Disable_Second(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  CurrenTDGLContext.GLStates.ActiveTexture := 1;
  glDisable(cap);
end;

procedure TexCoordPointer_Second(size: TGLint; atype: TGLEnum; stride:
  TGLsizei; data: pointer);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glClientActiveTextureARB(GL_TEXTURE1);
  glTexCoordPointerEXT(size, atype, stride, data);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

procedure EnableClientState_Second(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glClientActiveTextureARB(GL_TEXTURE1);
  //glEnableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

procedure DisableClientState_Second(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glClientActiveTextureARB(GL_TEXTURE1);
  //glDisableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

// --------- Dual Texturing

procedure TexCoord2f_Dual(s, t: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord2fARB(s, t);
  glMultiTexCoord2fARB(GL_TEXTURE1, s, t);
end;

procedure TexCoord2fv_Dual(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord2fvARB(v);
  glMultiTexCoord2fvARB(GL_TEXTURE1, v);
end;

procedure TexCoord3f_Dual(s, t, r: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord3fARB(s, t, r);
  glMultiTexCoord3fARB(GL_TEXTURE1, s, t, r);
end;

procedure TexCoord3fv_Dual(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord3fvARB(v);
  glMultiTexCoord3fvARB(GL_TEXTURE1, v);
end;

procedure TexCoord4f_Dual(s, t, r, q: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord4fARB(s, t, r, q);
  glMultiTexCoord4fARB(GL_TEXTURE1, s, t, r, q);
end;

procedure TexCoord4fv_Dual(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glMultiTexCoord4fvARB(v);
  glMultiTexCoord4fvARB(GL_TEXTURE1, v);
end;

procedure TexGenf_Dual(coord, pname: TGLEnum; param: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glMultiTexGenfEXT(coord, pname, param);
    ActiveTexture := 1;
    glMultiTexGenfEXT(coord, pname, param);
  end;
end;

procedure TexGenfv_Dual(coord, pname: TGLEnum; params: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glMultiTexGenfvEXT(coord, pname, params);
    ActiveTexture := 1;
    glMultiTexGenfvEXT(coord, pname, params);
  end;
end;

procedure TexGeni_Dual(coord, pname: TGLEnum; param: TGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glMultiTexGeniEXT(coord, pname, param);
    ActiveTexture := 1;
    glMultiTexGeniEXT(coord, pname, param);
  end;
end;

procedure TexGeniv_Dual(coord, pname: TGLEnum; params: PGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glMultiTexGenivEXT(coord, pname, params);
    ActiveTexture := 1;
    glMultiTexGenivEXT(coord, pname, params);
  end;
end;

procedure Enable_Dual(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glEnable(cap);
    ActiveTexture := 1;
    glEnable(cap);
  end;
end;

procedure Disable_Dual(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  with CurrenTDGLContext.GLStates do
  begin
    ActiveTexture := 0;
    glDisable(cap);
    ActiveTexture := 1;
    glDisable(cap);
  end;
end;

procedure TexCoordPointer_Dual(size: TGLint; atype: TGLEnum; stride:
  TGLsizei; data: pointer);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  glTexCoordPointerEXT(size, atype, stride, data); // or glMultiTexCoordPointerEXT ????
  glClientActiveTextureARB(GL_TEXTURE1);
  glTexCoordPointerEXT(size, atype, stride, data);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

procedure EnableClientState_Dual(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
 // glEnableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE1);
//  glEnableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

procedure DisableClientState_Dual(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
  //glDisableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE1);
  //glDisableClientState(aArray);
  glClientActiveTextureARB(GL_TEXTURE0);
end;

// --------- Null Texturing

procedure TexCoord2f_Null(s, t: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoord2fv_Null(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoord3f_Null(s, t, r: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoord3fv_Null(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoord4f_Null(s, t, r, q: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoord4fv_Null(v: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexGenf_Null(coord, pname: TGLEnum; param: TGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexGenfv_Null(coord, pname: TGLEnum; params: PGLfloat);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexGeni_Null(coord, pname: TGLEnum; param: TGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexGeniv_Null(coord, pname: TGLEnum; params: PGLint);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure Enable_Null(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure Disable_Null(cap: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure TexCoordPointer_Null(size: TGLint; atype: TGLEnum; stride:
  TGLsizei; data: pointer);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure EnableClientState_Null(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

procedure DisableClientState_Null(aArray: TGLEnum);
{$IFDEF MSWINDOWS} stdcall;
{$ENDIF}{$IFDEF unix} cdecl;
{$ENDIF}
begin
end;

// ------------------------------------------------------------------
// Redirections management functions
// ------------------------------------------------------------------

// BeginUpdate
//

procedure TGLMultitextureCoordinator.BeginUpdate;
begin
  if FUpdCount = 0 then
  begin
    FUpdCount := 1;
    FUpdNewMode := MapTexCoordMode;
  end
  else
    Inc(FUpdCount);
end;

// EndUpdate
//

procedure TGLMultitextureCoordinator.EndUpdate;
begin
  Dec(FUpdCount);
  if (FUpdCount = 0) and (FUpdNewMode <> MapTexCoordMode) then
  begin
    case FUpdNewMode of
      mtcmNull: MapTexCoordToNull;
      mtcmMain: MapTexCoordToMain;
      mtcmDual: MapTexCoordToDual;
      mtcmSecond: MapTexCoordToSecond;
      mtcmArbitrary: MapTexCoordToArbitrary(FComplexMapping);
    else
      Assert(False);
    end;
  end;
end;

// PushState
//

procedure TGLMultitextureCoordinator.PushState;
var
  i: Integer;
begin
  Assert(FUpdCount = 0);
  i := Length(FStateStack);
  SetLength(FStateStack, i + 1);
  FStateStack[i] := MapTexCoordMode;
end;

// PopState
//

procedure TGLMultitextureCoordinator.PopState;
var
  i: Integer;
begin
  Assert(FUpdCount = 0);
  i := Length(FStateStack) - 1;
  Assert(i >= 0);
  case FStateStack[i] of
    mtcmNull: MapTexCoordToNull;
    mtcmMain: MapTexCoordToMain;
    mtcmDual: MapTexCoordToDual;
    mtcmSecond: MapTexCoordToSecond;
    mtcmArbitrary: MapTexCoordToArbitrary(FComplexMapping);
  else
    Assert(False);
  end;
  SetLength(FStateStack, i);
end;

// ForbidSecondTextureUnit
//

procedure TGLMultitextureCoordinator.ForbidSecondTextureUnit;
begin
  FSecondTextureUnitForbidden := True;
end;

// AllowSecondTextureUnit
//

procedure TGLMultitextureCoordinator.AllowSecondTextureUnit;
begin
  FSecondTextureUnitForbidden := False;
end;

constructor TGLMultitextureCoordinator.Create(AOwner: TDGLContext);
begin
  inherited Create(AOwner);
  FMapTexCoordMode := mtcmUndefined;
  MapTexCoordToNull;
end;

// MapTexCoordToNull
//

procedure TGLMultitextureCoordinator.MapTexCoordToNull;
begin
  if FUpdCount <> 0 then
    FUpdNewMode := mtcmNull
  else if MapTexCoordMode <> mtcmNull then
  begin
    MapTexCoordMode := mtcmNull;

    TexCoord2f := TexCoord2f_Null;
    TexCoord2fv := TexCoord2fv_Null;
    TexCoord3f := TexCoord3f_Null;
    TexCoord3fv := TexCoord3fv_Null;
    TexCoord4f := TexCoord4f_Null;
    TexCoord4fv := TexCoord4fv_Null;

    TexGenf := TexGenf_Null;
    TexGenfv := TexGenfv_Null;
    TexGeni := TexGeni_Null;
    TexGeniv := TexGeniv_Null;

    TexCoordPointer := TexCoordPointer_Null;
    EnableClientState := EnableClientState_Null;
    DisableClientState := DisableClientState_Null;

    Enable := Enable_Null;
    Disable := Disable_Null;
  end;
end;

// TexCoordMapToMain
//

procedure TGLMultitextureCoordinator.MapTexCoordToMain;
begin
  if FUpdCount <> 0 then
    FUpdNewMode := mtcmMain
  else if MapTexCoordMode <> mtcmMain then
  begin
    MapTexCoordMode := mtcmMain;

    TexCoord2f := glMultiTexCoord2fARB;
    TexCoord2fv := glMultiTexCoord2fvARB;
    TexCoord3f := glMultiTexCoord3fARB;
    TexCoord3fv := glMultiTexCoord3fvARB;
    TexCoord4f := glMultiTexCoord4fARB;
    TexCoord4fv := glMultiTexCoord4fvARB;

    TexGenf := glMultiTexGenfEXT;
    TexGenfv := glMultiTexGenfvEXT;
    TexGeni := glMultiTexGeniEXT;
    TexGeniv := glMultiTexGenivEXT;

    TexCoordPointer := glTexCoordPointerEXT;
//    EnableClientState := glEnableClientState;
//    DisableClientState := glDisableClientState;

    Enable := glEnable;
    Disable := glDisable;
  end;
end;

// TexCoordMapToSecond
//

procedure TGLMultitextureCoordinator.MapTexCoordToSecond;
begin
  if FSecondTextureUnitForbidden then
  begin
    MapTexCoordToNull;
    Exit;
  end;
  if FUpdCount <> 0 then
    FUpdNewMode := mtcmSecond
  else if MapTexCoordMode <> mtcmSecond then
  begin
    MapTexCoordMode := mtcmSecond;
    Assert(not(dglCheckExtension('ARB_multitexture')));

    TexCoord2f := TexCoord2f_Second;
    TexCoord2fv := TexCoord2fv_Second;
    TexCoord3f := TexCoord3f_Second;
    TexCoord3fv := TexCoord3fv_Second;
    TexCoord4f := TexCoord4f_Second;
    TexCoord4fv := TexCoord4fv_Second;

    TexGenf := TexGenf_Second;
    TexGenfv := TexGenfv_Second;
    TexGeni := TexGeni_Second;
    TexGeniv := TexGeniv_Second;

    TexCoordPointer := TexCoordPointer_Second;
    EnableClientState := EnableClientState_Second;
    DisableClientState := DisableClientState_Second;

    Enable := Enable_Second;
    Disable := Disable_Second;
  end;
end;

// TexCoordMapToDual
//

procedure TGLMultitextureCoordinator.MapTexCoordToDual;
begin
  if FSecondTextureUnitForbidden then
  begin
    MapTexCoordToMain;
    Exit;
  end;
  if FUpdCount <> 0 then
    FUpdNewMode := mtcmDual
  else if MapTexCoordMode <> mtcmDual then
  begin
    MapTexCoordMode := mtcmDual;
    Assert(not(dglCheckExtension('ARB_multitexture')));

    TexCoord2f := TexCoord2f_Dual;
    TexCoord2fv := TexCoord2fv_Dual;
    TexCoord3f := TexCoord3f_Dual;
    TexCoord3fv := TexCoord3fv_Dual;
    TexCoord4f := TexCoord4f_Dual;
    TexCoord4fv := TexCoord4fv_Dual;

    TexGenf := TexGenf_Dual;
    TexGenfv := TexGenfv_Dual;
    TexGeni := TexGeni_Dual;
    TexGeniv := TexGeniv_Dual;

    TexCoordPointer := TexCoordPointer_Dual;
    EnableClientState := EnableClientState_Dual;
    DisableClientState := DisableClientState_Dual;

    Enable := Enable_Dual;
    Disable := Disable_Dual;
  end;
end;

// MapTexCoordToArbitrary (array)
//

procedure TGLMultitextureCoordinator.MapTexCoordToArbitrary(const units: array of Cardinal);
var
  i, j, n: Integer;
begin
  n := Length(units);
  SetLength(FComplexMapping, n);
  j := 0;
  FComplexMappingN := n - 1;
  for i := 0 to FComplexMappingN do
  begin
    if (not FSecondTextureUnitForbidden) or (units[i] <> GL_TEXTURE1) then
    begin
      FComplexMapping[j] := units[i];
      Inc(j);
    end;
  end;

  if FUpdCount <> 0 then
    FUpdNewMode := mtcmArbitrary
  else if MapTexCoordMode <> mtcmArbitrary then
  begin

    MapTexCoordMode := mtcmArbitrary;
    Assert(not(dglCheckExtension('ARB_multitexture')));

    TexCoord2f := TexCoord2f_Arbitrary;
    TexCoord2fv := TexCoord2fv_Arbitrary;
    TexCoord3f := TexCoord3f_Arbitrary;
    TexCoord3fv := TexCoord3fv_Arbitrary;
    TexCoord4f := TexCoord4f_Arbitrary;
    TexCoord4fv := TexCoord4fv_Arbitrary;

    TexGenf := TexGenf_Arbitrary;
    TexGenfv := TexGenfv_Arbitrary;
    TexGeni := TexGeni_Arbitrary;
    TexGeniv := TexGeniv_Arbitrary;

    TexCoordPointer := TexCoordPointer_Arbitrary;
    EnableClientState := EnableClientState_Arbitrary;
    DisableClientState := DisableClientState_Arbitrary;

    Enable := Enable_Arbitrary;
    Disable := Disable_Arbitrary;
  end;
end;

// MapTexCoordToArbitrary (bitwise)
//

procedure TGLMultitextureCoordinator.MapTexCoordToArbitrary(const bitWiseUnits: Cardinal);
var
  i, n: Integer;
  units: array of Cardinal;
begin
  n := 0;
  for i := 0 to 7 do
  begin
    if (bitWiseUnits and (1 shl i)) <> 0 then
      Inc(n);
  end;
  SetLength(units, n);
  n := 0;
  for i := 0 to 7 do
  begin
    if (bitWiseUnits and (1 shl i)) <> 0 then
    begin
      units[n] := GL_TEXTURE0 + i;
      Inc(n);
    end;
  end;
  MapTexCoordToArbitrary(units);
end;

// MapTexCoordToArbitrary (bitwise)
//

procedure TGLMultitextureCoordinator.MapTexCoordToArbitraryAdd(const bitWiseUnits: Cardinal);
var
  n: Cardinal;
begin
  n := GetBitWiseMapping;
  MapTexCoordToArbitrary(n or bitWiseUnits);
end;

// GetBitWiseMapping
//

function TGLMultitextureCoordinator.GetBitWiseMapping: Cardinal;
var
  i, n: Cardinal;
  mode: TMapTexCoordMode;
begin
  if FUpdCount > 0 then
    mode := FUpdNewMode
  else
    mode := MapTexCoordMode;
  n := 0;
  case mode of
    mtcmMain: n := 1;
    mtcmDual: n := 3;
    mtcmSecond: n := 2;
    mtcmArbitrary:
      begin
        for i := 0 to FComplexMappingN do
          n := n or (1 shl (FComplexMapping[i] - GL_TEXTURE0));
      end;
  else
    Assert(False);
  end;
  Result := n;
end;

initialization

  // Register class
  vMultitextureCoordinatorClass := TGLMultitextureCoordinator;

end.
