//
// This unit is part of the DGLEngine Project, http://DGLEngine.org
//
{ : DGLWin32Context<p>

  Base classes and structures for DGLEngine's Objects.<p>

  <b>Historique : </b><font size=-1><ul>
  <li>21/12/15 - JD -  Imported From GLScene
  </ul></font>
}
unit DGLBaseObjects;

interface

uses
  Winapi.Windows,
  System.Classes, System.SysUtils, System.Math,
  VCL.Graphics, VCL.Controls,

  // DGLE
  GLSLog, dglOpenGL, DGLCrossPlatform, DGLResStrings, DGLTypes, DGLUtils,
  DGLContext, DGLRenderContextInfo, DGLState,
  DGLBaseClasses,DGLPersistentClasses,DGLXCollection, DGLApplicationFileIO,

  DGLVectorMaths,
  DGLVectorTypes,
  DGLVectorLists,
  DGLGeometryBB,
  DGLCoordinates,

  DGLGraphics,
  DGLColor,
  DGLTextureFormat,
  //GLTexture,
  DGLMaterial,

  GLSilhouette,
  GLSelection,
  XOpenGL;
Type
  // TGLProxyObjectOption
  //
  { : Defines which features are taken from the master object. }
  TGLProxyObjectOption  = (pooEffects, pooObjects, pooTransformation);
  TGLProxyObjectOptions = set of TGLProxyObjectOption;

const
  cDefaultProxyOptions = [pooEffects, pooObjects, pooTransformation];

Type
  // TObjectChanges
  //
  // used to decribe only the changes in an object,
  // which have to be reflected in the scene
  TObjectChange  = (ocTransformation, ocAbsoluteMatrix, ocInvAbsoluteMatrix, ocStructure);
  TObjectChanges = set of TObjectChange;

  TObjectBBChange  = (oBBcChild, oBBcStructure);
  TObjectBBChanges = set of TObjectBBChange;

  // TDirectRenderEvent
  //
  { : Event for user-specific rendering in a TGLDirectOpenGL object. }
  TDirectRenderEvent = procedure(Sender: TObject; var rci: TRenderContextInfo) of object;

  // TGLCameraInvarianceMode
  //
  TDGLCameraInvarianceMode = (cimNone, cimPosition, cimOrientation);

  TNormalDirection = (ndInside, ndOutside);
  // TDGLScene = class;
  TDGLBaseSceneObject   = class;
  TDGLSceneObjectClass  = class of TDGLBaseSceneObject;
  TDGLCustomSceneObject = class;
  TGLBehaviour          = class;
  TGLBehaviourClass     = class of TGLBehaviour;
  TGLBehaviours         = class;

  TGLObjectEffect      = class;
  TGLObjectEffectClass = class of TGLObjectEffect;
  TGLObjectEffects     = class;
  // TGLObjectStyle
  //
  { : Possible styles/options for a GLScene object.<p>
    Allowed styles are:<ul>
    <li>osDirectDraw : object shall not make use of compiled call lists, but issue
    direct calls each time a render should be performed.
    <li>osIgnoreDepthBuffer : object is rendered with depth test disabled,
    this is true for its children too.
    <li>osNoVisibilityCulling : whatever the VisibilityCulling setting,
    it will be ignored and the object rendered
    </ul> }
  TGLObjectStyle  = (osDirectDraw, osIgnoreDepthBuffer, osNoVisibilityCulling);
  TGLObjectStyles = set of TGLObjectStyle;

  // IGLInitializable
  //
  { : Interface to objects that need initialization<p> }
  IGLInitializable = interface
    ['{EA40AE8E-79B3-42F5-ADF1-7A901B665E12}']
    procedure InitializeObject(ASender: TObject; const ARci: TRenderContextInfo);
  end;

  // TGLInitializableObjectList
  //
  { : Just a list of objects that support IGLInitializable.<p> }
  TGLInitializableObjectList = class(TList)
  private
    function GetItems(const Index: Integer): IGLInitializable;
    procedure PutItems(const Index: Integer; const Value: IGLInitializable);
  public
    function Add(const Item: IGLInitializable): Integer;
    property Items[const Index: Integer]: IGLInitializable read GetItems write PutItems; default;
  end;

  // TDGLSceneRootObject
  //
  { : This class shall be used only as a hierarchy root.<p>
    It exists only as a container and shall never be rotated/scaled etc. as
    the class type is used in parenting optimizations.<p>
    Shall never implement or add any functionality, the "Create" override
    only take cares of disabling the build list. }
  TDGLSceneRootObject = class(TDGLBaseSceneObject)
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
  end;

  // TDGLBaseSceneObject
  //
  { : Base class for all scene objects.<p>
    A scene object is part of scene hierarchy (each scene object can have
    multiple children), this hierarchy primarily defines transformations
    (each child coordinates are relative to its parent), but is also used
    for depth-sorting, bounding and visibility culling purposes.<p>
    Subclasses implement either visual scene objects (that are made to be
    visible at runtime, like a Cube) or structural objects (that influence
    rendering or are used for varied structural manipulations,
    like the ProxyObject).<p>
    To add children at runtime, use the AddNewChild method of TDGLBaseSceneObject;
    other children manipulations methods and properties are provided (to browse,
    move and delete them). Using the regular TComponent methods is not
    encouraged. }

  TDGLBaseSceneObject = class(TDGLCoordinatesUpdateAbleComponent)
  private
    { Private Declarations }
    FAbsoluteMatrix, FInvAbsoluteMatrix: PMatrix;
    FLocalMatrix:                        PMatrix;
    FObjectStyle:                        TGLObjectStyles;
//    FListHandle: TGLListHandle; // created on 1st use DEPRECATED

    // FVertices : TVectorList;
    // FNormals  : TAffineVectorList;
    // FIndices  : TIntegerList;
    // FTexCoord : TVectorList;
    // FTangents : TVectorList;
    // FBinormals : TAffineVectorList;

    FPosition:       TDGLCoordinates;
    FDirection, FUp: TDGLCoordinates;
    FScaling:        TDGLCoordinates;
    FChanges:        TObjectChanges;
    FParent:         TDGLBaseSceneObject;
    FScene:          TObject;

    FBBChanges:                    TObjectBBChanges;
    FBoundingBoxPersonalUnscaled:  THmgBoundingBox;
    FBoundingBoxOfChildren:        THmgBoundingBox;
    FBoundingBoxIncludingChildren: THmgBoundingBox;

    FChildren:          TPersistentObjectList; // created on 1st use
    FVisible:           Boolean;
    FUpdateCount:       Integer;
    FShowAxes:          Boolean;
    FRotation:          TDGLCoordinates; // current rotation angles
    FIsCalculating:     Boolean;
    FObjectsSorting:    TDGLObjectsSorting;
    FVisibilityCulling: TDGLVisibilityCulling;
    FOnProgress:        TDGLProgressEvent;
    FOnAddedToParent:   TNotifyEvent;
    FGLBehaviours:      TGLBehaviours;
    FGLObjectEffects:   TGLObjectEffects;
    FPickable:          Boolean;
    FOnPicked:          TNotifyEvent;

    FTagObject: TObject;
    FTagFloat:  Single;

    // FOriginalFiler: TFiler;   //used to allow persistent events in behaviours & effects
    { If somebody could look at DefineProperties, ReadBehaviours, ReadEffects and verify code
      is safe to use then it could be uncommented }

    function Get(Index: Integer): TDGLBaseSceneObject;
    function GetCount: Integer;
    function GetIndex: Integer;
    procedure SetParent(const val: TDGLBaseSceneObject);
    procedure SetIndex(aValue: Integer);
    procedure SetDirection(AVector: TDGLCoordinates);
    procedure SetUp(AVector: TDGLCoordinates);
    function GetMatrix: TMatrix;
    procedure SetMatrix(const aValue: TMatrix);
    procedure SetPosition(APosition: TDGLCoordinates);

    procedure SetPitchAngle(aValue: Single);
    procedure SetRollAngle(aValue: Single);
    procedure SetTurnAngle(aValue: Single);
    procedure SetRotation(aRotation: TDGLCoordinates);
    function GetPitchAngle: Single;
    function GetTurnAngle: Single;
    function GetRollAngle: Single;

    procedure SetShowAxes(aValue: Boolean);
    procedure SetScaling(aValue: TDGLCoordinates);
    procedure SetObjectsSorting(const val: TDGLObjectsSorting);
    procedure SetVisibilityCulling(const val: TDGLVisibilityCulling);
    procedure SetBehaviours(const val: TGLBehaviours);
    function GetBehaviours: TGLBehaviours;
    procedure SetEffects(const val: TGLObjectEffects);
    function GetEffects: TGLObjectEffects;

    function GetAbsoluteAffineScale: TAffineVector;
    function GetAbsoluteScale: TVector;
    procedure SetAbsoluteAffineScale(const Value: TAffineVector);
    procedure SetAbsoluteScale(const Value: TVector);

    function GetAbsoluteMatrix: TMatrix;
    procedure SetAbsoluteMatrix(const Value: TMatrix);
    procedure SetBBChanges(const Value: TObjectBBChanges);
  protected
    { Protected Declarations }
    procedure Loaded; override;
    procedure SetScene(const Value: TObject); virtual;

    procedure DefineProperties(Filer: TFiler); override;
    procedure WriteBehaviours(stream: TStream);
    procedure ReadBehaviours(stream: TStream);
    procedure WriteEffects(stream: TStream);
    procedure ReadEffects(stream: TStream);
    procedure WriteRotations(stream: TStream);
    procedure ReadRotations(stream: TStream);

    function GetVisible: Boolean; virtual;
    function GetPickable: Boolean; virtual;
    procedure SetVisible(aValue: Boolean); virtual;
    procedure SetPickable(aValue: Boolean); virtual;

    procedure SetAbsolutePosition(const v: TVector);
    function GetAbsolutePosition: TVector;
    procedure SetAbsoluteUp(const v: TVector);
    function GetAbsoluteUp: TVector;
    procedure SetAbsoluteDirection(const v: TVector);
    function GetAbsoluteDirection: TVector;

    function GetAbsoluteAffinePosition: TAffineVector;
    procedure SetAbsoluteAffinePosition(const Value: TAffineVector);
    procedure SetAbsoluteAffineUp(const v: TAffineVector);
    function GetAbsoluteAffineUp: TAffineVector;
    procedure SetAbsoluteAffineDirection(const v: TAffineVector);
    function GetAbsoluteAffineDirection: TAffineVector;

    procedure RecTransformationChanged;

    procedure DrawAxes(var rci: TRenderContextInfo; pattern: Word);
    procedure GetChildren(AProc: TGetChildProc; Root: TComponent); override;
    // : Should the object be considered as blended for sorting purposes?
    function Blended: Boolean; virtual;
    procedure RebuildMatrix;
    procedure SetName(const NewName: TComponentName); override;
    procedure SetParentComponent(Value: TComponent); override;
    procedure DestroyHandle; dynamic;
    procedure DestroyHandles;
    procedure DeleteChildCameras;
    procedure DoOnAddedToParent; virtual;

    { : Used to re-calculate BoundingBoxes every time we need it.
      GetLocalUnscaleBB() must return the local BB, not the axis-aligned one.

      By default it is calculated from AxisAlignedBoundingBoxUnscaled and
      BarycenterAbsolutePosition, but for most objects there is a more
      efficient method, that's why it is virtual. }
    procedure CalculateBoundingBoxPersonalUnscaled(var ANewBoundingBox: THmgBoundingBox); virtual;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    constructor CreateAsChild(aParentOwner: TDGLBaseSceneObject);
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;

    { : Controls and adjusts internal optimizations based on object's style.<p>
      Advanced user only. }
    property ObjectStyle: TGLObjectStyles read FObjectStyle write FObjectStyle;

    { : Returns the handle to the object's build list.<p>
      Use with caution! Some objects don't support buildlists! }
    function GetHandle(var rci: TRenderContextInfo): Cardinal; virtual;
    function ListHandleAllocated: Boolean;

    { : The local transformation (relative to parent).<p>
      If you're *sure* the local matrix is up-to-date, you may use LocalMatrix
      for quicker access. }
    property Matrix: TMatrix read GetMatrix write SetMatrix;
    { : See Matrix. }
    function MatrixAsAddress: PMatrix;
    { : Holds the local transformation (relative to parent).<p>
      If you're not *sure* the local matrix is up-to-date, use Matrix property. }
    property LocalMatrix: PMatrix read FLocalMatrix;
    { : Forces the local matrix to the specified value.<p>
      AbsoluteMatrix, InverseMatrix, etc. will honour that change, but
      may become invalid if the specified matrix isn't orthonormal (can
      be used for specific rendering or projection effects).<br>
      The local matrix will be reset by the next TransformationChanged,
      position or attitude change. }
    procedure ForceLocalMatrix(const aMatrix: TMatrix);

    { : See AbsoluteMatrix. }
    function AbsoluteMatrixAsAddress: PMatrix;
    { : Holds the absolute transformation matrix.<p>
      If you're not *sure* the absolute matrix is up-to-date,
      use the AbsoluteMatrix property, this one may be nil... }
    property DirectAbsoluteMatrix: PMatrix read FAbsoluteMatrix;

    { : Calculates the object's absolute inverse matrix.<p>
      Multiplying an absolute coordinate with this matrix gives a local coordinate.<p>
      The current implem uses transposition(AbsoluteMatrix), which is true
      unless you're using some scaling... }
    function InvAbsoluteMatrix: TMatrix;
    { : See InvAbsoluteMatrix. }
    function InvAbsoluteMatrixAsAddress: PMatrix;

    { : The object's absolute matrix by composing all local matrices.<p>
      Multiplying a local coordinate with this matrix gives an absolute coordinate. }
    property AbsoluteMatrix: TMatrix read GetAbsoluteMatrix write SetAbsoluteMatrix;

    { : Direction vector in absolute coordinates. }
    property AbsoluteDirection: TVector read GetAbsoluteDirection write SetAbsoluteDirection;
    property AbsoluteAffineDirection: TAffineVector read GetAbsoluteAffineDirection write SetAbsoluteAffineDirection;

    { : Scale vector in absolute coordinates.
      Warning: SetAbsoluteScale() does not work correctly at the moment. }
    property AbsoluteScale: TVector read GetAbsoluteScale write SetAbsoluteScale;
    property AbsoluteAffineScale: TAffineVector read GetAbsoluteAffineScale write SetAbsoluteAffineScale;

    { : Up vector in absolute coordinates. }
    property AbsoluteUp: TVector read GetAbsoluteUp write SetAbsoluteUp;
    property AbsoluteAffineUp: TAffineVector read GetAbsoluteAffineUp write SetAbsoluteAffineUp;

    { : Calculate the right vector in absolute coordinates. }
    function AbsoluteRight: TVector;

    { : Calculate the left vector in absolute coordinates. }
    function AbsoluteLeft: TVector;

    { : Computes and allows to set the object's absolute coordinates.<p> }
    property AbsolutePosition: TVector read GetAbsolutePosition write SetAbsolutePosition;
    property AbsoluteAffinePosition: TAffineVector read GetAbsoluteAffinePosition write SetAbsoluteAffinePosition;
    function AbsolutePositionAsAddress: PVector;

    { : Returns the Absolute X Vector expressed in local coordinates. }
    function AbsoluteXVector: TVector;
    { : Returns the Absolute Y Vector expressed in local coordinates. }
    function AbsoluteYVector: TVector;
    { : Returns the Absolute Z Vector expressed in local coordinates. }
    function AbsoluteZVector: TVector;

    { : Converts a vector/point from absolute coordinates to local coordinates.<p> }
    function AbsoluteToLocal(const v: TVector): TVector; overload;
    { : Converts a vector from absolute coordinates to local coordinates.<p> }
    function AbsoluteToLocal(const v: TAffineVector): TAffineVector; overload;
    { : Converts a vector/point from local coordinates to absolute coordinates.<p> }
    function LocalToAbsolute(const v: TVector): TVector; overload;
    { : Converts a vector from local coordinates to absolute coordinates.<p> }
    function LocalToAbsolute(const v: TAffineVector): TAffineVector; overload;

    { : Returns the Right vector (based on Up and Direction) }
    function Right: TVector;
    { : Returns the Left vector (based on Up and Direction) }
    function LeftVector: TVector;

    { : Returns the Right vector (based on Up and Direction) }
    function AffineRight: TAffineVector;
    { : Returns the Left vector (based on Up and Direction) }
    function AffineLeftVector: TAffineVector;

    { : Calculates the object's square distance to a point/object.<p>
      pt is assumed to be in absolute coordinates,
      AbsolutePosition is considered as being the object position. }
    function SqrDistanceTo(anObject: TDGLBaseSceneObject): Single; overload;
    function SqrDistanceTo(const pt: TVector): Single; overload;
    function SqrDistanceTo(const pt: TAffineVector): Single; overload;

    { : Computes the object's distance to a point/object.<p>
      Only objects AbsolutePositions are considered. }
    function DistanceTo(anObject: TDGLBaseSceneObject): Single; overload;
    function DistanceTo(const pt: TAffineVector): Single; overload;
    function DistanceTo(const pt: TVector): Single; overload;

    { : Calculates the object's barycenter in absolute coordinates.<p>
      Default behaviour is to consider Barycenter=AbsolutePosition
      (whatever the number of children).<br>
      SubClasses where AbsolutePosition is not the barycenter should
      override this method as it is used for distance calculation, during
      rendering for instance, and may lead to visual inconsistencies. }
    function BarycenterAbsolutePosition: TVector; virtual;
    { : Calculates the object's barycenter distance to a point.<p> }
    function BarycenterSqrDistanceTo(const pt: TVector): Single;

    { : Shall returns the object's axis aligned extensions.<p>
      The dimensions are measured from object center and are expressed
      <i>with</i> scale accounted for, in the object's coordinates
      (not in absolute coordinates).<p>
      Default value is half the object's Scale.<br> }
    function AxisAlignedDimensions: TVector; virtual;
    function AxisAlignedDimensionsUnscaled: TVector; virtual;

    { : Calculates and return the AABB for the object.<p>
      The AABB is currently calculated from the BB.
      There is <b>no</b> caching scheme for them. }
    function AxisAlignedBoundingBox(const AIncludeChilden: Boolean = True): TAABB;
    function AxisAlignedBoundingBoxUnscaled(const AIncludeChilden: Boolean = True): TAABB;
    function AxisAlignedBoundingBoxAbsolute(const AIncludeChilden: Boolean = True; const AUseBaryCenter: Boolean = False): TAABB;

    { : Advanced AABB functions that use a caching scheme.
      Also they include children and use BaryCenter. }
    function AxisAlignedBoundingBoxEx: TAABB;
    function AxisAlignedBoundingBoxAbsoluteEx: TAABB;

    { : Calculates and return the Bounding Box for the object.<p>
      The BB is calculated <b>each</b> time this method is invoked,
      based on the AxisAlignedDimensions of the object and that of its
      children.
      There is <b>no</b> caching scheme for them. }
    function BoundingBox(const AIncludeChilden: Boolean = True; const AUseBaryCenter: Boolean = False): THmgBoundingBox;
    function BoundingBoxUnscaled(const AIncludeChilden: Boolean = True; const AUseBaryCenter: Boolean = False): THmgBoundingBox;
    function BoundingBoxAbsolute(const AIncludeChilden: Boolean = True; const AUseBaryCenter: Boolean = False): THmgBoundingBox;

    { : Advanced BB functions that use a caching scheme.
      Also they include children and use BaryCenter. }
    function BoundingBoxPersonalUnscaledEx: THmgBoundingBox;
    function BoundingBoxOfChildrenEx: THmgBoundingBox;
    function BoundingBoxIncludingChildrenEx: THmgBoundingBox;

    { : Max distance of corners of the BoundingBox. }
    function BoundingSphereRadius: Single;
    function BoundingSphereRadiusUnscaled: Single;

    { : Indicates if a point is within an object.<p>
      Given coordinate is an absolute coordinate.<br>
      Linear or surfacic objects shall always return False.<p>
      Default value is based on AxisAlignedDimension and a cube bounding. }
    function PointInObject(const point: TVector): Boolean; virtual;
    { : Request to determine an intersection with a casted ray.<p>
      Given coordinates & vector are in absolute coordinates, rayVector
      must be normalized.<br>
      rayStart may be a point inside the object, allowing retrieval of
      the multiple intersects of the ray.<p>
      When intersectXXX parameters are nil (default) implementation should
      take advantage of this to optimize calculus, if not, and an intersect
      is found, non nil parameters should be defined.<p>
      The intersectNormal needs NOT be normalized by the implementations.<p>
      Default value is based on bounding sphere. }
    function RayCastIntersect(const rayStart, rayVector: TVector; intersectPoint: PVector = nil; intersectNormal: PVector = nil): Boolean; virtual;

    { : Request to generate silhouette outlines.<p>
      Default implementation assumes the objects is a sphere of
      AxisAlignedDimensionUnscaled size. Subclasses may choose to return
      nil instead, which will be understood as an empty silhouette. }
    function GenerateSilhouette(const silhouetteParameters: TGLSilhouetteParameters): TGLSilhouette; virtual;

    property Children[Index: Integer]: TDGLBaseSceneObject read Get; default;
    property Count: Integer read GetCount;
    property Index: Integer read GetIndex write SetIndex;
    // : Create a new scene object and add it to this object as new child
    function AddNewChild(AChild: TDGLSceneObjectClass): TDGLBaseSceneObject; dynamic;
    // : Create a new scene object and add it to this object as first child
    function AddNewChildFirst(AChild: TDGLSceneObjectClass): TDGLBaseSceneObject; dynamic;
    procedure AddChild(AChild: TDGLBaseSceneObject); dynamic;

    function GetOrCreateBehaviour(aBehaviour: TGLBehaviourClass): TGLBehaviour;
    function AddNewBehaviour(aBehaviour: TGLBehaviourClass): TGLBehaviour;

    function GetOrCreateEffect(anEffect: TGLObjectEffectClass): TGLObjectEffect;
    function AddNewEffect(anEffect: TGLObjectEffectClass): TGLObjectEffect;

    function HasSubChildren: Boolean;
    procedure DeleteChildren; dynamic;
    procedure Insert(AIndex: Integer; AChild: TDGLBaseSceneObject); dynamic;
    { : Takes a scene object out of the child list, but doesn't destroy it.<p>
      If 'KeepChildren' is true its children will be kept as new children
      in this scene object. }
    procedure Remove(AChild: TDGLBaseSceneObject; keepChildren: Boolean); dynamic;
    function IndexOfChild(AChild: TDGLBaseSceneObject): Integer;
    function FindChild(const aName: string; ownChildrenOnly: Boolean): TDGLBaseSceneObject;
    { : The "safe" version of this procedure checks if indexes are inside
      the list. If not, no exception if raised. }
    procedure ExchangeChildrenSafe(anIndex1, anIndex2: Integer);
    { : The "regular" version of this procedure does not perform any checks
      and calls FChildren.Exchange directly. User should/can perform range
      checks manualy. }
    procedure ExchangeChildren(anIndex1, anIndex2: Integer);
    { : These procedures are safe. }
    procedure MoveChildUp(anIndex: Integer);
    procedure MoveChildDown(anIndex: Integer);
    procedure MoveChildFirst(anIndex: Integer);
    procedure MoveChildLast(anIndex: Integer);

    procedure DoProgress(const progressTime: TProgressTimes); override;
    procedure MoveTo(newParent: TDGLBaseSceneObject); dynamic;
    procedure MoveUp;
    procedure MoveDown;
    procedure MoveFirst;
    procedure MoveLast;
    procedure BeginUpdate; virtual;
    procedure EndUpdate; virtual;
    { : Make object-specific geometry description here.<p>
      Subclasses should MAINTAIN OpenGL states (restore the states if
      they were altered). }
    procedure BuildList(var rci: TRenderContextInfo); virtual;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    function IsUpdating: Boolean;
    // : Moves the object along the Up vector (move up/down)
    procedure Lift(ADistance: Single);
    // : Moves the object along the direction vector
    procedure Move(ADistance: Single);
    // : Translates the object
    procedure Translate(tx, ty, tz: Single);
    procedure MoveObjectAround(anObject: TDGLBaseSceneObject; pitchDelta, turnDelta: Single);
    procedure MoveObjectAllAround(anObject: TDGLBaseSceneObject; pitchDelta, turnDelta: Single);
    procedure Pitch(angle: Single);
    procedure Roll(angle: Single);
    procedure Turn(angle: Single);

    { : Sets all rotations to zero and restores default Direction/Up.<p>
      Using this function then applying roll/pitch/turn in the order that
      suits you, you can give an "absolute" meaning to rotation angles
      (they are still applied locally though).<br>
      Scale and Position are not affected. }
    procedure ResetRotations;
    { : Reset rotations and applies them back in the specified order. }
    procedure ResetAndPitchTurnRoll(const degX, degY, degZ: Single);

    { : Applies rotations around absolute X, Y and Z axis.<p> }
    procedure RotateAbsolute(const rx, ry, rz: Single); overload;
    { : Applies rotations around the absolute given vector (angle in degrees).<p> }
    procedure RotateAbsolute(const axis: TAffineVector; angle: Single); overload;
    // : Moves camera along the right vector (move left and right)
    procedure Slide(ADistance: Single);
    // : Orients the object toward a target object
    procedure PointTo(const ATargetObject: TDGLBaseSceneObject; const AUpVector: TVector); overload;
    // : Orients the object toward a target absolute position
    procedure PointTo(const AAbsolutePosition, AUpVector: TVector); overload;

    procedure Render(var ARci: TRenderContextInfo);
    procedure DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean); virtual;
    procedure RenderChildren(firstChildIndex, lastChildIndex: Integer; var rci: TRenderContextInfo); virtual;

    procedure StructureChanged; dynamic;
    procedure ClearStructureChanged;

    // : Recalculate an orthonormal system
    procedure CoordinateChanged(Sender: TDGLCustomCoordinates); override;
    procedure TransformationChanged;
    procedure NotifyChange(Sender: TObject); override;

    property Rotation: TDGLCoordinates read FRotation write SetRotation;
    property PitchAngle: Single read GetPitchAngle write SetPitchAngle;
    property RollAngle: Single read GetRollAngle write SetRollAngle;
    property TurnAngle: Single read GetTurnAngle write SetTurnAngle;

    property ShowAxes: Boolean read FShowAxes write SetShowAxes default False;

    property Changes: TObjectChanges read FChanges;
    property BBChanges: TObjectBBChanges read FBBChanges write SetBBChanges;

    property Parent: TDGLBaseSceneObject read FParent write SetParent;
    property Position: TDGLCoordinates read FPosition write SetPosition;
    property Direction: TDGLCoordinates read FDirection write SetDirection;
    property Up: TDGLCoordinates read FUp write SetUp;
    property Scale: TDGLCoordinates read FScaling write SetScaling;
    property Scene: TObject read FScene; // A TDGLScene
    property Visible: Boolean read FVisible write SetVisible default True;
    property Pickable: Boolean read FPickable write SetPickable default True;
    property ObjectsSorting: TDGLObjectsSorting read FObjectsSorting write SetObjectsSorting default osInherited;
    property VisibilityCulling: TDGLVisibilityCulling read FVisibilityCulling write SetVisibilityCulling default vcInherited;
    property OnProgress: TDGLProgressEvent read FOnProgress write FOnProgress;
    property OnPicked: TNotifyEvent read FOnPicked write FOnPicked;
    property OnAddedToParent: TNotifyEvent read FOnAddedToParent write FOnAddedToParent;
    property Behaviours: TGLBehaviours read GetBehaviours write SetBehaviours stored False;
    property Effects: TGLObjectEffects read GetEffects write SetEffects stored False;

    property TagObject: TObject read FTagObject write FTagObject;
  published
    { Published Declarations }
    property TagFloat: Single read FTagFloat write FTagFloat;

  end;

  // TGLBaseBehaviour
  //
  { : Base class for implementing behaviours in TDGLScene.<p>
    Behaviours are regrouped in a collection attached to a TDGLBaseSceneObject,
    and are part of the "Progress" chain of events. Behaviours allows clean
    application of time-based alterations to objects (movements, shape or
    texture changes...).<p>
    Since behaviours are implemented as classes, there are basicly two kinds
    of strategies for subclasses :<ul>
    <li>stand-alone : the subclass does it all, and holds all necessary data
    (covers animation, inertia etc.)
    <li>proxy : the subclass is an interface to and external, shared operator
    (like gravity, force-field effects etc.)
    </ul><br>
    Some behaviours may be cooperative (like force-fields affects inertia)
    or unique (e.g. only one inertia behaviour per object).<p>
    NOTES :<ul>
    <li>Don't forget to override the ReadFromFiler/WriteToFiler persistence
    methods if you add data in a subclass !
    <li>Subclasses must be registered using the RegisterXCollectionItemClass
    function
    </ul> }
  TGLBaseBehaviour = class(TDGLXCollectionItem)
  protected
    { Protected Declarations }
    procedure SetName(const val: string); override;

    { : Override this function to write subclass data. }
    procedure WriteToFiler(writer: TWriter); override;
    { : Override this function to read subclass data. }
    procedure ReadFromFiler(reader: TReader); override;

    { : Returns the TDGLBaseSceneObject on which the behaviour should be applied.<p>
      Does NOT check for nil owners. }
    function OwnerBaseSceneObject: TDGLBaseSceneObject;

  public
    { Public Declarations }
    constructor Create(AOwner: TDGLXCollection); override;
    destructor Destroy; override;

    procedure DoProgress(const progressTime: TProgressTimes); virtual;
  end;

  // TGLBehaviour
  //
  { : Ancestor for non-rendering behaviours.<p>
    This class shall never receive any properties, it's just here to differentiate
    rendereing and non-rendering behaviours. Rendereing behaviours are named
    "TGLObjectEffect", non-rendering effects (like inertia) are simply named
    "TGLBehaviour". }

  TGLBehaviour = class(TGLBaseBehaviour)
  end;

  // TGLBehaviours
  //
  { : Holds a list of TGLBehaviour objects.<p>
    This object expects itself to be owned by a TDGLBaseSceneObject.<p>
    As a TDGLXCollection (and contrary to a TCollection), this list can contain
    objects of varying class, the only constraint being that they should all
    be TGLBehaviour subclasses. }
  TGLBehaviours = class(TDGLXCollection)
  protected
    { Protected Declarations }
    function GetBehaviour(Index: Integer): TGLBehaviour;

  public
    { Public Declarations }
    constructor Create(AOwner: TPersistent); override;

    function GetNamePath: string; override;

    class function ItemsClass: TDGLXCollectionItemClass; override;

    property Behaviour[index: Integer]: TGLBehaviour read GetBehaviour; default;

    function CanAdd(aClass: TDGLXCollectionItemClass): Boolean; override;

    procedure DoProgress(const progressTimes: TProgressTimes);
  end;

  // TGLObjectEffect
  //
  { : A rendering effect that can be applied to SceneObjects.<p>
    ObjectEffect is a subclass of behaviour that gets a chance to Render
    an object-related special effect.<p>
    TGLObjectEffect should not be used as base class for custom effects,
    instead you should use the following base classes :<ul>
    <li>TGLObjectPreEffect is rendered before owner object render
    <li>TGLObjectPostEffect is rendered after the owner object render
    <li>TGLObjectAfterEffect is rendered at the end of the scene rendering
    </ul><br>NOTES :<ul>
    <li>Don't forget to override the ReadFromFiler/WriteToFiler persistence
    methods if you add data in a subclass !
    <li>Subclasses must be registered using the RegisterXCollectionItemClass
    function
    </ul> }
  // TGLObjectEffectClass = class of TGLObjectEffect;

  TGLObjectEffect = class(TGLBaseBehaviour)
  protected
    { Protected Declarations }
    { : Override this function to write subclass data. }
    procedure WriteToFiler(writer: TWriter); override;
    { : Override this function to read subclass data. }
    procedure ReadFromFiler(reader: TReader); override;

  public
    { Public Declarations }
    procedure Render(var rci: TRenderContextInfo); virtual;
  end;

  // TGLObjectPreEffect
  //
  { : An object effect that gets rendered before owner object's render.<p>
    The current OpenGL matrices and material are that of the owner object. }
  TGLObjectPreEffect = class(TGLObjectEffect)
  end;

  // TGLObjectPostEffect
  //
  { : An object effect that gets rendered after owner object's render.<p>
    The current OpenGL matrices and material are that of the owner object. }
  TGLObjectPostEffect = class(TGLObjectEffect)
  end;

  // TGLObjectAfterEffect
  //
  { : An object effect that gets rendered at scene's end.<p>
    No particular OpenGL matrices or material should be assumed. }
  TGLObjectAfterEffect = class(TGLObjectEffect)
  end;

  // TGLObjectEffects
  //
  { : Holds a list of object effects.<p>
    This object expects itself to be owned by a TDGLBaseSceneObject.<p> }
  TGLObjectEffects = class(TDGLXCollection)
  protected
    { Protected Declarations }
    function GetEffect(Index: Integer): TGLObjectEffect;

  public
    { Public Declarations }
    constructor Create(AOwner: TPersistent); override;

    function GetNamePath: string; override;

    class function ItemsClass: TDGLXCollectionItemClass; override;

    property ObjectEffect[index: Integer]: TGLObjectEffect read GetEffect; default;

    function CanAdd(aClass: TDGLXCollectionItemClass): Boolean; override;

    procedure DoProgress(const progressTime: TProgressTimes);
    procedure RenderPreEffects(var rci: TRenderContextInfo);
    { : Also take care of registering after effects with the GLSceneViewer. }
    procedure RenderPostEffects(var rci: TRenderContextInfo);
  end;

  // TGLCustomSceneObject
  //
  { : Extended base scene object class with a material property.<p>
    The material allows defining a color and texture for the object,
    see TGLMaterial. }
  TGLCustomSceneObject = class(TDGLBaseSceneObject)
  private
    { Private Declarations }
    FMaterial: TDGLMaterial;
    FHint:     string;

  protected
    { Protected Declarations }
    function Blended: Boolean; override;

    procedure SetGLMaterial(aValue: TDGLMaterial);
    procedure DestroyHandle; override;
    procedure Loaded; override;

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Assign(Source: TPersistent); override;
    procedure DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean); override;

    property Material: TDGLMaterial read FMaterial write SetGLMaterial;
    property Hint: string read FHint write FHint;
  end;

  // TGLImmaterialSceneObject
  //
  { : Base class for objects that do not have a published "material".<p>
    Note that the material is available in public properties, but isn't
    applied automatically before invoking BuildList.<br>
    Subclassing should be reserved to structural objects and objects that
    have no material of their own. }
  TGLImmaterialSceneObject = class(TGLCustomSceneObject)
  public
    { Public Declarations }
    procedure DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean); override;

  published
    { Published Declarations }
    property ObjectsSorting;
    property VisibilityCulling;
    property Direction;
    property PitchAngle;
    property Position;
    property RollAngle;
    property Scale;
    property ShowAxes;
    property TurnAngle;
    property Up;
    property Visible;
    property Pickable;
    property OnProgress;
    property OnPicked;
    property Behaviours;
    property Effects;
    property Hint;
  end;

  // TGLCameraInvariantObject
  //
  { : Base class for camera invariant objects.<p>
    Camera invariant objects bypass camera settings, such as camera
    position (object is always centered on camera) or camera orientation
    (object always has same orientation as camera). }
  TGLCameraInvariantObject = class(TGLImmaterialSceneObject)
  private
    { Private Declarations }
    FCamInvarianceMode: TDGLCameraInvarianceMode;

  protected
    { Protected Declarations }
    procedure SetCamInvarianceMode(const val: TDGLCameraInvarianceMode);

    property CamInvarianceMode: TDGLCameraInvarianceMode read FCamInvarianceMode write SetCamInvarianceMode;

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;

    procedure Assign(Source: TPersistent); override;
    procedure DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean); override;
  end;

  // TDGLSceneObject
  //
  { : Base class for standard scene objects.<p>
    Publishes the Material property. }
  TDGLSceneObject = class(TGLCustomSceneObject)
  published
    { Published Declarations }
    property Material;
    property ObjectsSorting;
    property VisibilityCulling;
    property Direction;
    property PitchAngle;
    property Position;
    property RollAngle;
    property Scale;
    property ShowAxes;
    property TurnAngle;
    property Up;
    property Visible;
    property Pickable;
    property OnProgress;
    property OnPicked;
    property Behaviours;
    property Effects;
    property Hint;
  end;

  // TGLRenderPoint
  //
  { : Scene object that allows other objects to issue rendering at some point.<p>
    This object is used to specify a render point for which other components
    have (rendering) tasks to perform. It doesn't render anything itself
    and is invisible, but other components can register and be notified
    when the point is reached in the rendering phase.<br>
    Callbacks must be explicitly unregistered. }
  TGLRenderPoint = class(TGLImmaterialSceneObject)
  private
    { Private Declarations }
    FCallBacks:     array of TDirectRenderEvent;
    FFreeCallBacks: array of TNotifyEvent;

  protected
    { Protected Declarations }

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure BuildList(var rci: TRenderContextInfo); override;

    procedure RegisterCallBack(renderEvent: TDirectRenderEvent; renderPointFreed: TNotifyEvent);
    procedure UnRegisterCallBack(renderEvent: TDirectRenderEvent);
    procedure Clear;

  published
    { Published Declarations }
  end;

  // TGLProxyObject
  //
  { : A full proxy object.<p>
    This object literally uses another object's Render method to do its own
    rendering, however, it has a coordinate system and a life of its own.<br>
    Use it for duplicates of an object. }
  TGLProxyObject = class(TDGLBaseSceneObject)
  private
    { Private Declarations }
    FMasterObject: TDGLBaseSceneObject;
    FProxyOptions: TGLProxyObjectOptions;

  protected
    { Protected Declarations }
    FRendering: Boolean;

    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure SetMasterObject(const val: TDGLBaseSceneObject); virtual;
    procedure SetProxyOptions(const val: TGLProxyObjectOptions);

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Assign(Source: TPersistent); override;
    procedure DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean); override;

    function BarycenterAbsolutePosition: TVector; override;
    function AxisAlignedDimensions: TVector; override;
    function AxisAlignedDimensionsUnscaled: TVector; override;
    function RayCastIntersect(const rayStart, rayVector: TVector; intersectPoint: PVector = nil; intersectNormal: PVector = nil): Boolean; override;
    function GenerateSilhouette(const silhouetteParameters: TGLSilhouetteParameters): TGLSilhouette; override;

  published
    { Published Declarations }
    { : Specifies the Master object which will be proxy'ed. }
    property MasterObject: TDGLBaseSceneObject read FMasterObject write SetMasterObject;
    { : Specifies how and what is proxy'ed. }
    property ProxyOptions: TGLProxyObjectOptions read FProxyOptions write SetProxyOptions default cDefaultProxyOptions;

    property ObjectsSorting;
    property Direction;
    property PitchAngle;
    property Position;
    property RollAngle;
    property Scale;
    property ShowAxes;
    property TurnAngle;
    property Up;
    property Visible;
    property Pickable;
    property OnProgress;
    property OnPicked;
    property Behaviours;
  end;

  TGLProxyObjectClass = class of TGLProxyObject;

implementation

// ------------------
// ------------------ TDGLBaseSceneObject ------------------
// ------------------

// Create
//

constructor TDGLBaseSceneObject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FObjectStyle := [];
  FChanges     := [ocTransformation, ocStructure, ocAbsoluteMatrix, ocInvAbsoluteMatrix];
  FPosition    := TDGLCoordinates.CreateInitialized(Self, NullHmgPoint, csPoint);
  FRotation    := TDGLCoordinates.CreateInitialized(Self, NullHmgVector, csVector);
  FDirection   := TDGLCoordinates.CreateInitialized(Self, ZHmgVector, csVector);
  FUp          := TDGLCoordinates.CreateInitialized(Self, YHmgVector, csVector);
  FScaling     := TDGLCoordinates.CreateInitialized(Self, XYZHmgVector, csVector);
  GetMem(FLocalMatrix, SizeOf(TMatrix));
  FLocalMatrix^      := IdentityHmgMatrix;
  FVisible           := True;
  FPickable          := True;
  FObjectsSorting    := osInherited;
  FVisibilityCulling := vcInherited;

  FBBChanges                    := [oBBcChild, oBBcStructure];
  FBoundingBoxPersonalUnscaled  := NullBoundingBox;
  FBoundingBoxOfChildren        := NullBoundingBox;
  FBoundingBoxIncludingChildren := NullBoundingBox;
end;

// CreateAsChild
//

constructor TDGLBaseSceneObject.CreateAsChild(aParentOwner: TDGLBaseSceneObject);
begin
  Create(aParentOwner);
  aParentOwner.AddChild(Self);
end;

// Destroy
//

destructor TDGLBaseSceneObject.Destroy;
begin
  DeleteChildCameras;
  if assigned(FLocalMatrix) then
    FreeMem(FLocalMatrix, SizeOf(TMatrix));
  if assigned(FAbsoluteMatrix) then
    // This bug have coming surely from a bad commit file.
    FreeMem(FAbsoluteMatrix, SizeOf(TMatrix) * 2);
  // k00m memory fix and remove some leak of the old version.
  FGLObjectEffects.Free;
  FGLBehaviours.Free;
//  FListHandle.Free;
  FPosition.Free;
  FRotation.Free;
  FDirection.Free;
  FUp.Free;
  FScaling.Free;
  if assigned(FParent) then
    FParent.Remove(Self, False);
  if assigned(FChildren) then
  begin
    DeleteChildren;
    FChildren.Free;
  end;
  inherited Destroy;
end;

// GetHandle
//

function TDGLBaseSceneObject.GetHandle(var rci: TRenderContextInfo): Cardinal;
begin
//  if not assigned(FListHandle) then
//    FListHandle := TGLListHandle.Create;
//  Result        := FListHandle.Handle;
//  if Result = 0 then
//    Result := FListHandle.AllocateHandle;
//
//  if ocStructure in FChanges then
//  begin
//    ClearStructureChanged;
//    FListHandle.NotifyChangesOfData;
//  end;
//
//  if FListHandle.IsDataNeedUpdate then
//  begin
//    rci.GLStates.NewList(Result, GL_COMPILE);
//    try
//      BuildList(rci);
//    finally
//      rci.GLStates.EndList;
//    end;
//    FListHandle.NotifyDataUpdated;
//  end;
end;

// ListHandleAllocated
//

function TDGLBaseSceneObject.ListHandleAllocated: Boolean;
begin
//  Result := assigned(FListHandle) and (FListHandle.Handle <> 0) and
  result:=not(ocStructure in FChanges);
end;

// DestroyHandle
//

procedure TDGLBaseSceneObject.DestroyHandle;
begin
//  if assigned(FListHandle) then
//    FListHandle.DestroyHandle;
end;

// DestroyHandles
//

procedure TDGLBaseSceneObject.DestroyHandles;
var
  i: Integer;
begin
  for i := 0 to Count - 1 do
    Children[i].DestroyHandles;
  DestroyHandle;
end;

// SetBBChanges
//

procedure TDGLBaseSceneObject.SetBBChanges(const Value: TObjectBBChanges);
begin
  if Value <> FBBChanges then
  begin
    FBBChanges := Value;
    if assigned(FParent) then
      FParent.BBChanges := FParent.BBChanges + [oBBcChild];
  end;
end;

// Blended
//

function TDGLBaseSceneObject.Blended: Boolean;
begin
  Result := False;
end;

// BeginUpdate
//

procedure TDGLBaseSceneObject.BeginUpdate;
begin
  Inc(FUpdateCount);
end;

// EndUpdate
//

procedure TDGLBaseSceneObject.EndUpdate;
begin
  if FUpdateCount > 0 then
  begin
    Dec(FUpdateCount);
    if FUpdateCount = 0 then
      NotifyChange(Self);
  end
  else
    Assert(False, glsUnBalancedBeginEndUpdate);
end;

// BuildList
//

procedure TDGLBaseSceneObject.BuildList(var rci: TRenderContextInfo);
begin
  // nothing
end;

// DeleteChildCameras
//

procedure TDGLBaseSceneObject.DeleteChildCameras;
var
  i:     Integer;
  child: TDGLBaseSceneObject;
begin
  i := 0;
  if assigned(FChildren) then
    while i < FChildren.Count do
    begin
      child := TDGLBaseSceneObject(FChildren.List^[i]);
      child.DeleteChildCameras;
      if child is TDGLCamera then
      begin
        Remove(child, True);
        child.Free;
      end
      else
        Inc(i);
    end;
end;

// DeleteChildren
//

procedure TDGLBaseSceneObject.DeleteChildren;
var
  child: TDGLBaseSceneObject;
begin
  DeleteChildCameras;
  if assigned(FScene) then
  //  FScene.RemoveLights(Self);
  if assigned(FChildren) then
    while FChildren.Count > 0 do
    begin
      child         := TDGLBaseSceneObject(FChildren.Pop);
      child.FParent := nil;
      child.Free;
    end;
  BBChanges := BBChanges + [oBBcChild];
end;

// Loaded
//

procedure TDGLBaseSceneObject.Loaded;
begin
  inherited;
  FPosition.W := 1;
  if assigned(FGLBehaviours) then
    FGLBehaviours.Loaded;
  if assigned(FGLObjectEffects) then
    FGLObjectEffects.Loaded;
end;

// DefineProperties
//

procedure TDGLBaseSceneObject.DefineProperties(Filer: TFiler);
begin
  inherited;
  { FOriginalFiler := Filer; }

  Filer.DefineBinaryProperty('BehavioursData', ReadBehaviours, WriteBehaviours, (assigned(FGLBehaviours) and (FGLBehaviours.Count > 0)));
  Filer.DefineBinaryProperty('EffectsData', ReadEffects, WriteEffects, (assigned(FGLObjectEffects) and (FGLObjectEffects.Count > 0)));
  { FOriginalFiler:=nil; }
end;

// WriteBehaviours
//

procedure TDGLBaseSceneObject.WriteBehaviours(stream: TStream);
var
  writer: TWriter;
begin
  writer := TWriter.Create(stream, 16384);
  try
    Behaviours.WriteToFiler(writer);
  finally
    writer.Free;
  end;
end;

// ReadBehaviours
//

procedure TDGLBaseSceneObject.ReadBehaviours(stream: TStream);
var
  reader: TReader;
begin
  reader := TReader.Create(stream, 16384);
  { with TReader(FOriginalFiler) do }
  try
    { reader.Root                 := Root;
      reader.OnError              := OnError;
      reader.OnFindMethod         := OnFindMethod;
      reader.OnSetName            := OnSetName;
      reader.OnReferenceName      := OnReferenceName;
      reader.OnAncestorNotFound   := OnAncestorNotFound;
      reader.OnCreateComponent    := OnCreateComponent;
      reader.OnFindComponentClass := OnFindComponentClass; }
    Behaviours.ReadFromFiler(reader);
  finally
    reader.Free;
  end;
end;

// WriteEffects
//

procedure TDGLBaseSceneObject.WriteEffects(stream: TStream);
var
  writer: TWriter;
begin
  writer := TWriter.Create(stream, 16384);
  try
    Effects.WriteToFiler(writer);
  finally
    writer.Free;
  end;
end;

// ReadEffects
//

procedure TDGLBaseSceneObject.ReadEffects(stream: TStream);
var
  reader: TReader;
begin
  reader := TReader.Create(stream, 16384);
  { with TReader(FOriginalFiler) do }
  try
    { reader.Root                 := Root;
      reader.OnError              := OnError;
      reader.OnFindMethod         := OnFindMethod;
      reader.OnSetName            := OnSetName;
      reader.OnReferenceName      := OnReferenceName;
      reader.OnAncestorNotFound   := OnAncestorNotFound;
      reader.OnCreateComponent    := OnCreateComponent;
      reader.OnFindComponentClass := OnFindComponentClass; }
    Effects.ReadFromFiler(reader);
  finally
    reader.Free;
  end;
end;

// WriteRotations
//

procedure TDGLBaseSceneObject.WriteRotations(stream: TStream);
begin
  stream.Write(FRotation.AsAddress^, 3 * SizeOf(TGLFloat));
end;

// ReadRotations
//

procedure TDGLBaseSceneObject.ReadRotations(stream: TStream);
begin
  stream.Read(FRotation.AsAddress^, 3 * SizeOf(TGLFloat));
end;

// DrawAxes
//

procedure TDGLBaseSceneObject.DrawAxes(var rci: TRenderContextInfo; pattern: Word);
begin
//  AxesBuildList(rci, pattern, rci.rcci.farClippingDistance - rci.rcci.nearClippingDistance);
end;

// GetChildren
//

procedure TDGLBaseSceneObject.GetChildren(AProc: TGetChildProc; Root: TComponent);
var
  i: Integer;
begin
  if assigned(FChildren) then
    for i := 0 to FChildren.Count - 1 do
      if not IsSubComponent(TComponent(FChildren.List^[i])) then
        AProc(TComponent(FChildren.List^[i]));
end;

// Get
//

function TDGLBaseSceneObject.Get(Index: Integer): TDGLBaseSceneObject;
begin
  if assigned(FChildren) then
    Result := TDGLBaseSceneObject(FChildren[Index])
  else
    Result := nil;
end;

// GetCount
//

function TDGLBaseSceneObject.GetCount: Integer;
begin
  if assigned(FChildren) then
    Result := FChildren.Count
  else
    Result := 0;
end;

// HasSubChildren
//

function TDGLBaseSceneObject.HasSubChildren: Boolean;
var
  i: Integer;
begin
  Result := False;
  if Count <> 0 then
    for i := 0 to Count - 1 do
      if IsSubComponent(Children[i]) then
      begin
        Result := True;
        Exit;
      end;
end;

// AddChild
//

procedure TDGLBaseSceneObject.AddChild(AChild: TDGLBaseSceneObject);
begin
  if assigned(FScene) then
    FScene.AddLights(AChild);
  if not assigned(FChildren) then
    FChildren := TPersistentObjectList.Create;
  FChildren.Add(AChild);
  AChild.FParent := Self;
  AChild.SetScene(FScene);
  TransformationChanged;
  AChild.TransformationChanged;
  AChild.DoOnAddedToParent;
  BBChanges := BBChanges + [oBBcChild];
end;

// AddNewChild
//

function TDGLBaseSceneObject.AddNewChild(AChild: TDGLSceneObjectClass): TDGLBaseSceneObject;
begin
  Result := AChild.Create(Owner);
  AddChild(Result);
end;

// AddNewChildFirst
//

function TDGLBaseSceneObject.AddNewChildFirst(AChild: TDGLSceneObjectClass): TDGLBaseSceneObject;
begin
  Result := AChild.Create(Owner);
  Insert(0, Result);
end;

// GetOrCreateBehaviour
//

function TDGLBaseSceneObject.GetOrCreateBehaviour(aBehaviour: TGLBehaviourClass): TGLBehaviour;
begin
  Result := TGLBehaviour(Behaviours.GetOrCreate(aBehaviour));
end;

// AddNewBehaviour
//

function TDGLBaseSceneObject.AddNewBehaviour(aBehaviour: TGLBehaviourClass): TGLBehaviour;
begin
  Assert(Behaviours.CanAdd(aBehaviour));
  Result := aBehaviour.Create(Behaviours)
end;

// GetOrCreateEffect
//

function TDGLBaseSceneObject.GetOrCreateEffect(anEffect: TGLObjectEffectClass): TGLObjectEffect;
begin
  Result := TGLObjectEffect(Effects.GetOrCreate(anEffect));
end;

// AddNewEffect
//

function TDGLBaseSceneObject.AddNewEffect(anEffect: TGLObjectEffectClass): TGLObjectEffect;
begin
  Assert(Effects.CanAdd(anEffect));
  Result := anEffect.Create(Effects)
end;

// RebuildMatrix
//

procedure TDGLBaseSceneObject.RebuildMatrix;
begin
  if ocTransformation in Changes then
  begin
    VectorScale(LeftVector, Scale.X, FLocalMatrix^.v[0]);
    VectorScale(FUp.AsVector, Scale.Y, FLocalMatrix^.v[1]);
    VectorScale(FDirection.AsVector, Scale.Z, FLocalMatrix^.v[2]);
    SetVector(FLocalMatrix^.v[3], FPosition.AsVector);
    Exclude(FChanges, ocTransformation);
    Include(FChanges, ocAbsoluteMatrix);
    Include(FChanges, ocInvAbsoluteMatrix);
  end;
end;

// ForceLocalMatrix
//

procedure TDGLBaseSceneObject.ForceLocalMatrix(const aMatrix: TMatrix);
begin
  FLocalMatrix^ := aMatrix;
  Exclude(FChanges, ocTransformation);
  Include(FChanges, ocAbsoluteMatrix);
  Include(FChanges, ocInvAbsoluteMatrix);
end;

// AbsoluteMatrixAsAddress
//

function TDGLBaseSceneObject.AbsoluteMatrixAsAddress: PMatrix;
begin
  if ocAbsoluteMatrix in FChanges then
  begin
    RebuildMatrix;
    if not assigned(FAbsoluteMatrix) then
    begin
      GetMem(FAbsoluteMatrix, SizeOf(TMatrix) * 2);
      FInvAbsoluteMatrix := PMatrix(PtrUInt(FAbsoluteMatrix) + SizeOf(TMatrix));
    end;
    if assigned(Parent) and (not(Parent is TDGLSceneRootObject)) then
    begin
      MatrixMultiply(FLocalMatrix^, TDGLBaseSceneObject(Parent).AbsoluteMatrixAsAddress^, FAbsoluteMatrix^);
    end
    else
      FAbsoluteMatrix^ := FLocalMatrix^;
    Exclude(FChanges, ocAbsoluteMatrix);
    Include(FChanges, ocInvAbsoluteMatrix);
  end;
  Result := FAbsoluteMatrix;
end;

// InvAbsoluteMatrix
//

function TDGLBaseSceneObject.InvAbsoluteMatrix: TMatrix;
begin
  Result := InvAbsoluteMatrixAsAddress^;
end;

// InvAbsoluteMatrix
//

function TDGLBaseSceneObject.InvAbsoluteMatrixAsAddress: PMatrix;
begin
  if ocInvAbsoluteMatrix in FChanges then
  begin
    if VectorEquals(Scale.DirectVector, XYZHmgVector) then
    begin
      if not assigned(FAbsoluteMatrix) then
      begin
        GetMem(FAbsoluteMatrix, SizeOf(TMatrix) * 2);
        FInvAbsoluteMatrix := PMatrix(PtrUInt(FAbsoluteMatrix) + SizeOf(TMatrix));
      end;
      RebuildMatrix;
      if Parent <> nil then
        FInvAbsoluteMatrix^ := MatrixMultiply(Parent.InvAbsoluteMatrixAsAddress^, AnglePreservingMatrixInvert(FLocalMatrix^))
      else
        FInvAbsoluteMatrix^ := AnglePreservingMatrixInvert(FLocalMatrix^);
    end
    else
    begin
      FInvAbsoluteMatrix^ := AbsoluteMatrixAsAddress^;
      InvertMatrix(FInvAbsoluteMatrix^);
    end;
    Exclude(FChanges, ocInvAbsoluteMatrix);
  end;
  Result := FInvAbsoluteMatrix;
end;

// GetAbsoluteMatrix
//

function TDGLBaseSceneObject.GetAbsoluteMatrix: TMatrix;
begin
  Result := AbsoluteMatrixAsAddress^;
end;

// SetAbsoluteMatrix
//

procedure TDGLBaseSceneObject.SetAbsoluteMatrix(const Value: TMatrix);
begin
  if not MatrixEquals(Value, FAbsoluteMatrix^) then
  begin
    FAbsoluteMatrix^ := Value;
    if Parent <> nil then
      SetMatrix(MatrixMultiply(FAbsoluteMatrix^, Parent.InvAbsoluteMatrixAsAddress^))
    else
      SetMatrix(Value);
  end;
end;

// GetAbsoluteDirection
//

function TDGLBaseSceneObject.GetAbsoluteDirection: TVector;
begin
  Result := VectorNormalize(AbsoluteMatrixAsAddress^.v[2]);
end;

// SetAbsoluteDirection
//

procedure TDGLBaseSceneObject.SetAbsoluteDirection(const v: TVector);
begin
  if Parent <> nil then
    Direction.AsVector := Parent.AbsoluteToLocal(v)
  else
    Direction.AsVector := v;
end;

// GetAbsoluteScale
//

function TDGLBaseSceneObject.GetAbsoluteScale: TVector;
begin
  Result.v[0] := AbsoluteMatrixAsAddress^.v[0].v[0];
  Result.v[1] := AbsoluteMatrixAsAddress^.v[1].v[1];
  Result.v[2] := AbsoluteMatrixAsAddress^.v[2].v[2];

  Result.v[3] := 0;
end;

// SetAbsoluteScale
//

procedure TDGLBaseSceneObject.SetAbsoluteScale(const Value: TVector);
begin
  if Parent <> nil then
    Scale.AsVector := Parent.AbsoluteToLocal(Value)
  else
    Scale.AsVector := Value;
end;

// GetAbsoluteUp
//

function TDGLBaseSceneObject.GetAbsoluteUp: TVector;
begin
  Result := VectorNormalize(AbsoluteMatrixAsAddress^.v[1]);
end;

// SetAbsoluteUp
//

procedure TDGLBaseSceneObject.SetAbsoluteUp(const v: TVector);
begin
  if Parent <> nil then
    Up.AsVector := Parent.AbsoluteToLocal(v)
  else
    Up.AsVector := v;
end;

// AbsoluteRight
//

function TDGLBaseSceneObject.AbsoluteRight: TVector;
begin
  Result := VectorNormalize(AbsoluteMatrixAsAddress^.v[0]);
end;

// AbsoluteLeft
//

function TDGLBaseSceneObject.AbsoluteLeft: TVector;
begin
  Result := VectorNegate(AbsoluteRight);
end;

// GetAbsolutePosition
//

function TDGLBaseSceneObject.GetAbsolutePosition: TVector;
begin
  Result := AbsoluteMatrixAsAddress^.v[3];
end;

// SetAbsolutePosition
//

procedure TDGLBaseSceneObject.SetAbsolutePosition(const v: TVector);
begin
  if assigned(Parent) then
    Position.AsVector := Parent.AbsoluteToLocal(v)
  else
    Position.AsVector := v;
end;

// AbsolutePositionAsAddress
//

function TDGLBaseSceneObject.AbsolutePositionAsAddress: PVector;
begin
  Result := @AbsoluteMatrixAsAddress^.v[3];
end;

// AbsoluteXVector
//

function TDGLBaseSceneObject.AbsoluteXVector: TVector;
begin
  AbsoluteMatrixAsAddress;
  SetVector(Result, PAffineVector(@FAbsoluteMatrix.v[0])^);
end;

// AbsoluteYVector
//

function TDGLBaseSceneObject.AbsoluteYVector: TVector;
begin
  AbsoluteMatrixAsAddress;
  SetVector(Result, PAffineVector(@FAbsoluteMatrix.v[1])^);
end;

// AbsoluteZVector
//

function TDGLBaseSceneObject.AbsoluteZVector: TVector;
begin
  AbsoluteMatrixAsAddress;
  SetVector(Result, PAffineVector(@FAbsoluteMatrix.v[2])^);
end;

// AbsoluteToLocal (hmg)
//

function TDGLBaseSceneObject.AbsoluteToLocal(const v: TVector): TVector;
begin
  Result := VectorTransform(v, InvAbsoluteMatrixAsAddress^);
end;

// AbsoluteToLocal (affine)
//

function TDGLBaseSceneObject.AbsoluteToLocal(const v: TAffineVector): TAffineVector;
begin
  Result := VectorTransform(v, InvAbsoluteMatrixAsAddress^);
end;

// LocalToAbsolute (hmg)
//

function TDGLBaseSceneObject.LocalToAbsolute(const v: TVector): TVector;
begin
  Result := VectorTransform(v, AbsoluteMatrixAsAddress^);
end;

// LocalToAbsolute (affine)
//

function TDGLBaseSceneObject.LocalToAbsolute(const v: TAffineVector): TAffineVector;
begin
  Result := VectorTransform(v, AbsoluteMatrixAsAddress^);
end;

// Right
//

function TDGLBaseSceneObject.Right: TVector;
begin
  Result := VectorCrossProduct(FDirection.AsVector, FUp.AsVector);
end;

// LeftVector
//

function TDGLBaseSceneObject.LeftVector: TVector;
begin
  Result := VectorCrossProduct(FUp.AsVector, FDirection.AsVector);
end;

// BarycenterAbsolutePosition
//

function TDGLBaseSceneObject.BarycenterAbsolutePosition: TVector;
begin
  Result := AbsolutePosition;
end;

// SqrDistanceTo (obj)
//

function TDGLBaseSceneObject.SqrDistanceTo(anObject: TDGLBaseSceneObject): Single;
begin
  if assigned(anObject) then
    Result := VectorDistance2(AbsolutePosition, anObject.AbsolutePosition)
  else
    Result := 0;
end;

// SqrDistanceTo (vec4)
//

function TDGLBaseSceneObject.SqrDistanceTo(const pt: TVector): Single;
begin
  Result := VectorDistance2(pt, AbsolutePosition);
end;

// DistanceTo (obj)
//

function TDGLBaseSceneObject.DistanceTo(anObject: TDGLBaseSceneObject): Single;
begin
  if assigned(anObject) then
    Result := VectorDistance(AbsolutePosition, anObject.AbsolutePosition)
  else
    Result := 0;
end;

// DistanceTo (vec4)
//

function TDGLBaseSceneObject.DistanceTo(const pt: TVector): Single;
begin
  Result := VectorDistance(AbsolutePosition, pt);
end;

// BarycenterSqrDistanceTo
//

function TDGLBaseSceneObject.BarycenterSqrDistanceTo(const pt: TVector): Single;
var
  d: TVector;
begin
  d      := BarycenterAbsolutePosition;
  Result := VectorDistance2(d, pt);
end;

// AxisAlignedDimensions
//

function TDGLBaseSceneObject.AxisAlignedDimensions: TVector;
begin
  Result := AxisAlignedDimensionsUnscaled();
  ScaleVector(Result, Scale.AsVector);
end;

// AxisAlignedDimensionsUnscaled
//

function TDGLBaseSceneObject.AxisAlignedDimensionsUnscaled: TVector;
begin
  Result.v[0] := 0.5;
  Result.v[1] := 0.5;
  Result.v[2] := 0.5;
  Result.v[3] := 0;
end;

// AxisAlignedBoundingBox
//

function TDGLBaseSceneObject.AxisAlignedBoundingBox(const AIncludeChilden: Boolean): TAABB;
var
  i:     Integer;
  aabb:  TAABB;
  child: TDGLBaseSceneObject;
begin
  SetAABB(Result, AxisAlignedDimensionsUnscaled);
  // not tested for child objects
  if AIncludeChilden and assigned(FChildren) then
  begin
    for i := 0 to FChildren.Count - 1 do
    begin
      child := TDGLBaseSceneObject(FChildren.List^[i]);
      aabb  := child.AxisAlignedBoundingBoxUnscaled(AIncludeChilden);
      AABBTransform(aabb, child.Matrix);
      AddAABB(Result, aabb);
    end;
  end;
  AABBScale(Result, Scale.AsAffineVector);
end;

// AxisAlignedBoundingBoxUnscaled
//

function TDGLBaseSceneObject.AxisAlignedBoundingBoxUnscaled(const AIncludeChilden: Boolean): TAABB;
var
  i:    Integer;
  aabb: TAABB;
begin
  SetAABB(Result, AxisAlignedDimensionsUnscaled);
  // not tested for child objects
  if AIncludeChilden and assigned(FChildren) then
  begin
    for i := 0 to FChildren.Count - 1 do
    begin
      aabb := TDGLBaseSceneObject(FChildren.List^[i]).AxisAlignedBoundingBoxUnscaled(AIncludeChilden);
      AABBTransform(aabb, TDGLBaseSceneObject(FChildren.List^[i]).Matrix);
      AddAABB(Result, aabb);
    end;
  end;
end;

// AxisAlignedBoundingBoxAbsolute
//

function TDGLBaseSceneObject.AxisAlignedBoundingBoxAbsolute(const AIncludeChilden: Boolean; const AUseBaryCenter: Boolean): TAABB;
begin
  Result := BBToAABB(BoundingBoxAbsolute(AIncludeChilden, AUseBaryCenter));
end;

// BoundingBox
//

function TDGLBaseSceneObject.BoundingBox(const AIncludeChilden: Boolean; const AUseBaryCenter: Boolean): THmgBoundingBox;
var
  CurrentBaryOffset: TVector;
begin
  Result := AABBToBB(AxisAlignedBoundingBox(AIncludeChilden));

  // DaStr: code not tested...
  if AUseBaryCenter then
  begin
    CurrentBaryOffset := VectorSubtract(AbsoluteToLocal(BarycenterAbsolutePosition), Position.AsVector);
    OffsetBBPoint(Result, CurrentBaryOffset);
  end;
end;

// BoundingBoxUnscaled
//

function TDGLBaseSceneObject.BoundingBoxUnscaled(const AIncludeChilden: Boolean; const AUseBaryCenter: Boolean): THmgBoundingBox;
var
  CurrentBaryOffset: TVector;
begin
  Result := AABBToBB(AxisAlignedBoundingBoxUnscaled(AIncludeChilden));

  // DaStr: code not tested...
  if AUseBaryCenter then
  begin
    CurrentBaryOffset := VectorSubtract(AbsoluteToLocal(BarycenterAbsolutePosition), Position.AsVector);
    OffsetBBPoint(Result, CurrentBaryOffset);
  end;
end;

// BoundingBoxAbsolute
//

function TDGLBaseSceneObject.BoundingBoxAbsolute(const AIncludeChilden: Boolean; const AUseBaryCenter: Boolean): THmgBoundingBox;
var
  i:                 Integer;
  CurrentBaryOffset: TVector;
begin
  Result           := BoundingBoxUnscaled(AIncludeChilden, False);
  for i            := 0 to 7 do
    Result.BBox[i] := LocalToAbsolute(Result.BBox[i]);

  if AUseBaryCenter then
  begin
    CurrentBaryOffset := VectorSubtract(BarycenterAbsolutePosition, AbsolutePosition);
    OffsetBBPoint(Result, CurrentBaryOffset);
  end;
end;

// BoundingSphereRadius
//

function TDGLBaseSceneObject.BoundingSphereRadius: Single;
begin
  Result := VectorLength(AxisAlignedDimensions);
end;

// BoundingSphereRadiusUnscaled
//

function TDGLBaseSceneObject.BoundingSphereRadiusUnscaled: Single;
begin
  Result := VectorLength(AxisAlignedDimensionsUnscaled);
end;

// PointInObject
//

function TDGLBaseSceneObject.PointInObject(const point: TVector): Boolean;
var
  localPt, dim: TVector;
begin
  dim     := AxisAlignedDimensions;
  localPt := VectorTransform(point, InvAbsoluteMatrix);
  Result  := (Abs(localPt.v[0] * Scale.X) <= dim.v[0]) and (Abs(localPt.v[1] * Scale.Y) <= dim.v[1]) and (Abs(localPt.v[2] * Scale.Z) <= dim.v[2]);
end;

// CalculateBoundingBoxPersonalUnscaled
//

procedure TDGLBaseSceneObject.CalculateBoundingBoxPersonalUnscaled(var ANewBoundingBox: THmgBoundingBox);
begin
  // Using the standard method to get the local BB.
  ANewBoundingBox := AABBToBB(AxisAlignedBoundingBoxUnscaled(False));
  OffsetBBPoint(ANewBoundingBox, AbsoluteToLocal(BarycenterAbsolutePosition));
end;

// BoundingBoxPersonalUnscaledEx
//

function TDGLBaseSceneObject.BoundingBoxPersonalUnscaledEx: THmgBoundingBox;
begin
  if oBBcStructure in FBBChanges then
  begin
    CalculateBoundingBoxPersonalUnscaled(FBoundingBoxPersonalUnscaled);
    Exclude(FBBChanges, oBBcStructure);
  end;
  Result := FBoundingBoxPersonalUnscaled;
end;

// AxisAlignedBoundingBoxAbsoluteEx
//

function TDGLBaseSceneObject.AxisAlignedBoundingBoxAbsoluteEx: TAABB;
var
  pBB: THmgBoundingBox;
begin
  pBB := BoundingBoxIncludingChildrenEx;
  BBTransform(pBB, AbsoluteMatrix);
  Result := BBToAABB(pBB);
end;

// AxisAlignedBoundingBoxEx
//

function TDGLBaseSceneObject.AxisAlignedBoundingBoxEx: TAABB;
begin
  Result := BBToAABB(BoundingBoxIncludingChildrenEx);
  AABBScale(Result, Scale.AsAffineVector);
end;

// BoundingBoxOfChildrenEx
//

function TDGLBaseSceneObject.BoundingBoxOfChildrenEx: THmgBoundingBox;
var
  i:   Integer;
  pBB: THmgBoundingBox;
begin
  if oBBcChild in FBBChanges then
  begin
    // Computing
    FBoundingBoxOfChildren := NullBoundingBox;
    if assigned(FChildren) then
    begin
      for i := 0 to FChildren.Count - 1 do
      begin
        pBB := TDGLBaseSceneObject(FChildren.List^[i]).BoundingBoxIncludingChildrenEx;
        if not BoundingBoxesAreEqual(@pBB, @NullBoundingBox) then
        begin
          // transformation with local matrix
          BBTransform(pBB, TDGLBaseSceneObject(FChildren.List^[i]).Matrix);
          if BoundingBoxesAreEqual(@FBoundingBoxOfChildren, @NullBoundingBox) then
            FBoundingBoxOfChildren := pBB
          else
            AddBB(FBoundingBoxOfChildren, pBB);
        end;
      end;
    end;
    Exclude(FBBChanges, oBBcChild);
  end;
  Result := FBoundingBoxOfChildren;
end;

// BoundingBoxIncludingChildrenEx
//

function TDGLBaseSceneObject.BoundingBoxIncludingChildrenEx: THmgBoundingBox;
var
  pBB: THmgBoundingBox;
begin
  if (oBBcStructure in FBBChanges) or (oBBcChild in FBBChanges) then
  begin
    pBB := BoundingBoxPersonalUnscaledEx;
    if BoundingBoxesAreEqual(@pBB, @NullBoundingBox) then
      FBoundingBoxIncludingChildren := BoundingBoxOfChildrenEx
    else
    begin
      FBoundingBoxIncludingChildren := pBB;
      pBB                           := BoundingBoxOfChildrenEx;
      if not BoundingBoxesAreEqual(@pBB, @NullBoundingBox) then
        AddBB(FBoundingBoxIncludingChildren, pBB);
    end;
  end;
  Result := FBoundingBoxIncludingChildren;
end;

// RayCastIntersect
//

function TDGLBaseSceneObject.RayCastIntersect(const rayStart, rayVector: TVector; intersectPoint: PVector = nil; intersectNormal: PVector = nil): Boolean;
var
  i1, i2, absPos: TVector;
begin
  SetVector(absPos, AbsolutePosition);
  if RayCastSphereIntersect(rayStart, rayVector, absPos, BoundingSphereRadius, i1, i2) > 0 then
  begin
    Result := True;
    if assigned(intersectPoint) then
      SetVector(intersectPoint^, i1);
    if assigned(intersectNormal) then
    begin
      SubtractVector(i1, absPos);
      NormalizeVector(i1);
      SetVector(intersectNormal^, i1);
    end;
  end
  else
    Result := False;
end;

// GenerateSilhouette
//

function TDGLBaseSceneObject.GenerateSilhouette(const silhouetteParameters: TGLSilhouetteParameters): TGLSilhouette;
const
  cNbSegments = 21;
var
  i, j:                        Integer;
  d, r, vr, s, c, angleFactor: Single;
  sVec, tVec:                  TAffineVector;
begin
  r := BoundingSphereRadiusUnscaled;
  d := VectorLength(silhouetteParameters.SeenFrom);
  // determine visible radius
  case silhouetteParameters.Style of
    ssOmni:
      vr := SphereVisibleRadius(d, r);
    ssParallel:
      vr := r;
  else
    Assert(False);
    vr := r;
  end;
  // determine a local orthonormal matrix, viewer-oriented
  sVec := VectorCrossProduct(silhouetteParameters.SeenFrom, XVector);
  if VectorLength(sVec) < 1E-3 then
    sVec := VectorCrossProduct(silhouetteParameters.SeenFrom, YVector);
  tVec   := VectorCrossProduct(silhouetteParameters.SeenFrom, sVec);
  NormalizeVector(sVec);
  NormalizeVector(tVec);
  // generate the silhouette (outline and capping)
  Result      := TGLSilhouette.Create;
  angleFactor := (2 * PI) / cNbSegments;
  vr          := vr * 0.98;
  for i       := 0 to cNbSegments - 1 do
  begin
    SinCosine(i * angleFactor, vr, s, c);
    Result.Vertices.AddPoint(VectorCombine(sVec, tVec, s, c));
    j := (i + 1) mod cNbSegments;
    Result.Indices.Add(i, j);
    if silhouetteParameters.CappingRequired then
      Result.CapIndices.Add(cNbSegments, i, j)
  end;
  if silhouetteParameters.CappingRequired then
    Result.Vertices.Add(NullHmgPoint);
end;

// Assign
//

procedure TDGLBaseSceneObject.Assign(Source: TPersistent);
var
  i:               Integer;
  child, newChild: TDGLBaseSceneObject;
begin
  if assigned(Source) and (Source is TDGLBaseSceneObject) then
  begin
    DestroyHandles;
    FVisible := TDGLBaseSceneObject(Source).FVisible;
    TDGLBaseSceneObject(Source).RebuildMatrix;
    SetMatrix(TDGLBaseSceneObject(Source).FLocalMatrix^);
    FShowAxes          := TDGLBaseSceneObject(Source).FShowAxes;
    FObjectsSorting    := TDGLBaseSceneObject(Source).FObjectsSorting;
    FVisibilityCulling := TDGLBaseSceneObject(Source).FVisibilityCulling;
    FRotation.Assign(TDGLBaseSceneObject(Source).FRotation);
    DeleteChildren;
    if assigned(Scene) then
      Scene.BeginUpdate;
    if assigned(TDGLBaseSceneObject(Source).FChildren) then
    begin
      for i := 0 to TDGLBaseSceneObject(Source).FChildren.Count - 1 do
      begin
        child    := TDGLBaseSceneObject(TDGLBaseSceneObject(Source).FChildren[i]);
        newChild := AddNewChild(TDGLSceneObjectClass(child.ClassType));
        newChild.Assign(child);
      end;
    end;
    if assigned(Scene) then
      Scene.EndUpdate;
    OnProgress := TDGLBaseSceneObject(Source).OnProgress;
    if assigned(TDGLBaseSceneObject(Source).FGLBehaviours) then
      Behaviours.Assign(TDGLBaseSceneObject(Source).Behaviours)
    else
      FreeAndNil(FGLBehaviours);
    if assigned(TDGLBaseSceneObject(Source).FGLObjectEffects) then
      Effects.Assign(TDGLBaseSceneObject(Source).Effects)
    else
      FreeAndNil(FGLObjectEffects);
    Tag       := TDGLBaseSceneObject(Source).Tag;
    FTagFloat := TDGLBaseSceneObject(Source).FTagFloat;
  end
  else
    inherited Assign(Source);
end;

// IsUpdating
//

function TDGLBaseSceneObject.IsUpdating: Boolean;
begin
  Result := (FUpdateCount <> 0) or (csReading in ComponentState);
end;

// GetParentComponent
//

function TDGLBaseSceneObject.GetParentComponent: TComponent;
begin
  if FParent is TDGLSceneRootObject then
    Result := FScene
  else
    Result := FParent;
end;

// HasParent
//

function TDGLBaseSceneObject.HasParent: Boolean;
begin
  Result := assigned(FParent);
end;

// Lift
//

procedure TDGLBaseSceneObject.Lift(ADistance: Single);
begin
  FPosition.AddScaledVector(ADistance, FUp.AsVector);
  TransformationChanged;
end;

// Move
//

procedure TDGLBaseSceneObject.Move(ADistance: Single);
begin
  FPosition.AddScaledVector(ADistance, FDirection.AsVector);
  TransformationChanged;
end;

// Slide
//

procedure TDGLBaseSceneObject.Slide(ADistance: Single);
begin
  FPosition.AddScaledVector(ADistance, Right);
  TransformationChanged;
end;

// ResetRotations
//

procedure TDGLBaseSceneObject.ResetRotations;
begin
  FillChar(FLocalMatrix^, SizeOf(TMatrix), 0);
  FLocalMatrix^.v[0].v[0] := Scale.DirectX;
  FLocalMatrix^.v[1].v[1] := Scale.DirectY;
  FLocalMatrix^.v[2].v[2] := Scale.DirectZ;
  SetVector(FLocalMatrix^.v[3], Position.DirectVector);
  FRotation.DirectVector  := NullHmgPoint;
  FDirection.DirectVector := ZHmgVector;
  FUp.DirectVector        := YHmgVector;
  TransformationChanged;
  Exclude(FChanges, ocTransformation);
end;

// ResetAndPitchTurnRoll
//

procedure TDGLBaseSceneObject.ResetAndPitchTurnRoll(const degX, degY, degZ: Single);
var
  rotMatrix: TMatrix;
  v:         TVector;
begin
  ResetRotations;
  // set DegX (Pitch)
  rotMatrix := CreateRotationMatrix(Right, degX * cPIdiv180);
  v         := VectorTransform(FUp.AsVector, rotMatrix);
  NormalizeVector(v);
  FUp.DirectVector := v;
  v                := VectorTransform(FDirection.AsVector, rotMatrix);
  NormalizeVector(v);
  FDirection.DirectVector := v;
  FRotation.DirectX       := NormalizeDegAngle(degX);
  // set DegY (Turn)
  rotMatrix := CreateRotationMatrix(FUp.AsVector, degY * cPIdiv180);
  v         := VectorTransform(FUp.AsVector, rotMatrix);
  NormalizeVector(v);
  FUp.DirectVector := v;
  v                := VectorTransform(FDirection.AsVector, rotMatrix);
  NormalizeVector(v);
  FDirection.DirectVector := v;
  FRotation.DirectY       := NormalizeDegAngle(degY);
  // set DegZ (Roll)
  rotMatrix := CreateRotationMatrix(Direction.AsVector, degZ * cPIdiv180);
  v         := VectorTransform(FUp.AsVector, rotMatrix);
  NormalizeVector(v);
  FUp.DirectVector := v;
  v                := VectorTransform(FDirection.AsVector, rotMatrix);
  NormalizeVector(v);
  FDirection.DirectVector := v;
  FRotation.DirectZ       := NormalizeDegAngle(degZ);
  TransformationChanged;
  NotifyChange(Self);
end;

// RotateAbsolute
//

procedure TDGLBaseSceneObject.RotateAbsolute(const rx, ry, rz: Single);
var
  resMat: TMatrix;
  v:      TAffineVector;
begin
  resMat := Matrix;
  // No we build rotation matrices and use them to rotate the obj
  if rx <> 0 then
  begin
    SetVector(v, AbsoluteToLocal(XVector));
    resMat := MatrixMultiply(CreateRotationMatrix(v, -DegToRadian(rx)), resMat);
  end;
  if ry <> 0 then
  begin
    SetVector(v, AbsoluteToLocal(YVector));
    resMat := MatrixMultiply(CreateRotationMatrix(v, -DegToRadian(ry)), resMat);
  end;
  if rz <> 0 then
  begin
    SetVector(v, AbsoluteToLocal(ZVector));
    resMat := MatrixMultiply(CreateRotationMatrix(v, -DegToRadian(rz)), resMat);
  end;
  Matrix := resMat;
end;

// RotateAbsolute
//

procedure TDGLBaseSceneObject.RotateAbsolute(const axis: TAffineVector; angle: Single);
var
  v: TAffineVector;
begin
  if angle <> 0 then
  begin
    SetVector(v, AbsoluteToLocal(axis));
    Matrix := MatrixMultiply(CreateRotationMatrix(v, DegToRadian(angle)), Matrix);
  end;
end;

// Pitch
//

procedure TDGLBaseSceneObject.Pitch(angle: Single);
var
  r:           Single;
  rightVector: TVector;
begin
  FIsCalculating := True;
  try
    angle       := -DegToRad(angle);
    rightVector := Right;
    FUp.Rotate(rightVector, angle);
    FUp.Normalize;
    FDirection.Rotate(rightVector, angle);
    FDirection.Normalize;
    r := -RadToDeg(ArcTan2(FDirection.Y, VectorLength(FDirection.X, FDirection.Z)));
    if FDirection.X < 0 then
      if FDirection.Y < 0 then
        r := 180 - r
      else
        r       := -180 - r;
    FRotation.X := r;
  finally
    FIsCalculating := False;
  end;
  TransformationChanged;
end;

// SetPitchAngle
//

procedure TDGLBaseSceneObject.SetPitchAngle(aValue: Single);
var
  diff:      Single;
  rotMatrix: TMatrix;
begin
  if aValue <> FRotation.X then
  begin
    if not(csLoading in ComponentState) then
    begin
      FIsCalculating := True;
      try
        diff             := DegToRadian(FRotation.X - aValue);
        rotMatrix        := CreateRotationMatrix(Right, diff);
        FUp.DirectVector := VectorTransform(FUp.AsVector, rotMatrix);
        FUp.Normalize;
        FDirection.DirectVector := VectorTransform(FDirection.AsVector, rotMatrix);
        FDirection.Normalize;
        TransformationChanged;
      finally
        FIsCalculating := False;
      end;
    end;
    FRotation.DirectX := NormalizeDegAngle(aValue);
  end;
end;

// Roll
//

procedure TDGLBaseSceneObject.Roll(angle: Single);
var
  r:                            Single;
  rightVector, directionVector: TVector;
begin
  FIsCalculating := True;
  try
    angle           := DegToRadian(angle);
    directionVector := Direction.AsVector;
    FUp.Rotate(directionVector, angle);
    FUp.Normalize;
    FDirection.Rotate(directionVector, angle);
    FDirection.Normalize;

    // calculate new rotation angle from vectors
    rightVector := Right;
    r           := -RadToDeg(ArcTan2(rightVector.v[1], VectorLength(rightVector.v[0], rightVector.v[2])));
    if rightVector.v[0] < 0 then
      if rightVector.v[1] < 0 then
        r := 180 - r
      else
        r       := -180 - r;
    FRotation.Z := r;
  finally
    FIsCalculating := False;
  end;
  TransformationChanged;
end;

// SetRollAngle
//

procedure TDGLBaseSceneObject.SetRollAngle(aValue: Single);
var
  diff:      Single;
  rotMatrix: TMatrix;
begin
  if aValue <> FRotation.Z then
  begin
    if not(csLoading in ComponentState) then
    begin
      FIsCalculating := True;
      try
        diff             := DegToRadian(FRotation.Z - aValue);
        rotMatrix        := CreateRotationMatrix(Direction.AsVector, diff);
        FUp.DirectVector := VectorTransform(FUp.AsVector, rotMatrix);
        FUp.Normalize;
        FDirection.DirectVector := VectorTransform(FDirection.AsVector, rotMatrix);
        FDirection.Normalize;
        TransformationChanged;
      finally
        FIsCalculating := False;
      end;
    end;
    FRotation.DirectZ := NormalizeDegAngle(aValue);
  end;
end;

// Turn
//

procedure TDGLBaseSceneObject.Turn(angle: Single);
var
  r:        Single;
  upVector: TVector;
begin
  FIsCalculating := True;
  try
    angle    := DegToRadian(angle);
    upVector := Up.AsVector;
    FUp.Rotate(upVector, angle);
    FUp.Normalize;
    FDirection.Rotate(upVector, angle);
    FDirection.Normalize;
    r := -RadToDeg(ArcTan2(FDirection.X, VectorLength(FDirection.Y, FDirection.Z)));
    if FDirection.X < 0 then
      if FDirection.Y < 0 then
        r := 180 - r
      else
        r       := -180 - r;
    FRotation.Y := r;
  finally
    FIsCalculating := False;
  end;
  TransformationChanged;
end;

// SetTurnAngle
//

procedure TDGLBaseSceneObject.SetTurnAngle(aValue: Single);
var
  diff:      Single;
  rotMatrix: TMatrix;
begin
  if aValue <> FRotation.Y then
  begin
    if not(csLoading in ComponentState) then
    begin
      FIsCalculating := True;
      try
        diff             := DegToRadian(FRotation.Y - aValue);
        rotMatrix        := CreateRotationMatrix(Up.AsVector, diff);
        FUp.DirectVector := VectorTransform(FUp.AsVector, rotMatrix);
        FUp.Normalize;
        FDirection.DirectVector := VectorTransform(FDirection.AsVector, rotMatrix);
        FDirection.Normalize;
        TransformationChanged;
      finally
        FIsCalculating := False;
      end;
    end;
    FRotation.DirectY := NormalizeDegAngle(aValue);
  end;
end;

// SetRotation
//

procedure TDGLBaseSceneObject.SetRotation(aRotation: TDGLCoordinates);
begin
  FRotation.Assign(aRotation);
  TransformationChanged;
end;

// GetPitchAngle
//

function TDGLBaseSceneObject.GetPitchAngle: Single;
begin
  Result := FRotation.X;
end;

// GetTurnAngle
//

function TDGLBaseSceneObject.GetTurnAngle: Single;
begin
  Result := FRotation.Y;
end;

// GetRollAngle
//

function TDGLBaseSceneObject.GetRollAngle: Single;
begin
  Result := FRotation.Z;
end;

// PointTo
//

procedure TDGLBaseSceneObject.PointTo(const ATargetObject: TDGLBaseSceneObject; const AUpVector: TVector);
begin
  PointTo(ATargetObject.AbsolutePosition, AUpVector);
end;

// PointTo
//

procedure TDGLBaseSceneObject.PointTo(const AAbsolutePosition, AUpVector: TVector);
var
  absDir, absRight, absUp: TVector;
begin
  // first compute absolute attitude for pointing
  absDir := VectorSubtract(AAbsolutePosition, Self.AbsolutePosition);
  NormalizeVector(absDir);
  absRight := VectorCrossProduct(absDir, AUpVector);
  NormalizeVector(absRight);
  absUp := VectorCrossProduct(absRight, absDir);
  // convert absolute to local and adjust object
  if Parent <> nil then
  begin
    FDirection.AsVector := Parent.AbsoluteToLocal(absDir);
    FUp.AsVector        := Parent.AbsoluteToLocal(absUp);
  end
  else
  begin
    FDirection.AsVector := absDir;
    FUp.AsVector        := absUp;
  end;
  TransformationChanged
end;

// SetShowAxes
//

procedure TDGLBaseSceneObject.SetShowAxes(aValue: Boolean);
begin
  if FShowAxes <> aValue then
  begin
    FShowAxes := aValue;
    NotifyChange(Self);
  end;
end;

// SetScaling
//

procedure TDGLBaseSceneObject.SetScaling(aValue: TDGLCoordinates);
begin
  FScaling.Assign(aValue);
  TransformationChanged;
end;

// SetName
//

procedure TDGLBaseSceneObject.SetName(const NewName: TComponentName);
begin
  if Name <> NewName then
  begin
    inherited SetName(NewName);
    if assigned(vGLBaseSceneObjectNameChangeEvent) then
      vGLBaseSceneObjectNameChangeEvent(Self);
  end;
end;

// SetParent
//

procedure TDGLBaseSceneObject.SetParent(const val: TDGLBaseSceneObject);
begin
  MoveTo(val);
end;

// GetIndex
//

function TDGLBaseSceneObject.GetIndex: Integer;
begin
  if assigned(FParent) then
    Result := FParent.FChildren.IndexOf(Self)
  else
    Result := -1;
end;

// SetIndex
//

procedure TDGLBaseSceneObject.SetIndex(aValue: Integer);
var
  LCount:       Integer;
  parentBackup: TDGLBaseSceneObject;
begin
  if assigned(FParent) then
  begin
    if aValue < 0 then
      aValue := 0;
    LCount   := FParent.Count;
    if aValue >= LCount then
      aValue := LCount - 1;
    if aValue <> Index then
    begin
      if assigned(FScene) then
        FScene.BeginUpdate;
      parentBackup := FParent;
      parentBackup.Remove(Self, False);
      parentBackup.Insert(aValue, Self);
      if assigned(FScene) then
        FScene.EndUpdate;
    end;
  end;
end;

// SetParentComponent
//

procedure TDGLBaseSceneObject.SetParentComponent(Value: TComponent);
begin
  inherited;
  if Value = FParent then
    Exit;

  if Value is TDGLScene then
    SetParent(TDGLScene(Value).Objects)
  else if Value is TDGLBaseSceneObject then
    SetParent(TDGLBaseSceneObject(Value))
  else
    SetParent(nil);
end;

// StructureChanged
//

procedure TDGLBaseSceneObject.StructureChanged;
begin
  if not(ocStructure in FChanges) then
  begin
    Include(FChanges, ocStructure);
    NotifyChange(Self);
  end
  else if osDirectDraw in ObjectStyle then
    NotifyChange(Self);
end;

// ClearStructureChanged
//

procedure TDGLBaseSceneObject.ClearStructureChanged;
begin
  Exclude(FChanges, ocStructure);
  SetBBChanges(BBChanges + [oBBcStructure]);
end;

// RecTransformationChanged
//

procedure TDGLBaseSceneObject.RecTransformationChanged;
var
  i:      Integer;
  List:   PPointerObjectList;
  matSet: TObjectChanges;
begin
  matSet := [ocAbsoluteMatrix, ocInvAbsoluteMatrix];
  if matSet * FChanges <> matSet then
  begin
    FChanges := FChanges + matSet;
    if assigned(FChildren) then
    begin
      List  := FChildren.List;
      for i := 0 to FChildren.Count - 1 do
        TDGLBaseSceneObject(List^[i]).RecTransformationChanged;
    end;
  end;
end;

// TransformationChanged
//

procedure TDGLBaseSceneObject.TransformationChanged;
begin
  if not(ocTransformation in FChanges) then
  begin
    Include(FChanges, ocTransformation);
    RecTransformationChanged;
    if not(csLoading in ComponentState) then
      NotifyChange(Self);
  end;
end;

// MoveTo
//

procedure TDGLBaseSceneObject.MoveTo(newParent: TDGLBaseSceneObject);
begin
  if newParent = FParent then
    Exit;
  if assigned(FParent) then
  begin
    FParent.Remove(Self, False);
    FParent := nil;
  end;
  if assigned(newParent) then
    newParent.AddChild(Self)
  else
    SetScene(nil);
end;

// MoveUp
//

procedure TDGLBaseSceneObject.MoveUp;
begin
  if assigned(Parent) then
    Parent.MoveChildUp(Parent.IndexOfChild(Self));
end;

// MoveDown
//

procedure TDGLBaseSceneObject.MoveDown;
begin
  if assigned(Parent) then
    Parent.MoveChildDown(Parent.IndexOfChild(Self));
end;

// MoveFirst
//

procedure TDGLBaseSceneObject.MoveFirst;
begin
  if assigned(Parent) then
    Parent.MoveChildFirst(Parent.IndexOfChild(Self));
end;

// MoveLast
//

procedure TDGLBaseSceneObject.MoveLast;
begin
  if assigned(Parent) then
    Parent.MoveChildLast(Parent.IndexOfChild(Self));
end;

// MoveObjectAroundTarget
//

procedure TDGLBaseSceneObject.MoveObjectAround(anObject: TDGLBaseSceneObject; pitchDelta, turnDelta: Single);
var
  originalT2C, normalT2C, normalCameraRight, newPos: TVector;
  pitchNow, dist:                                    Single;
begin
  if assigned(anObject) then
  begin
    // normalT2C points away from the direction the camera is looking
    originalT2C := VectorSubtract(AbsolutePosition, anObject.AbsolutePosition);
    SetVector(normalT2C, originalT2C);
    dist := VectorLength(normalT2C);
    NormalizeVector(normalT2C);
    // normalRight points to the camera's right
    // the camera is pitching around this axis.
    normalCameraRight := VectorCrossProduct(AbsoluteUp, normalT2C);
    if VectorLength(normalCameraRight) < 0.001 then
      SetVector(normalCameraRight, XVector) // arbitrary vector
    else
      NormalizeVector(normalCameraRight);
    // calculate the current pitch.
    // 0 is looking down and PI is looking up
    pitchNow := ArcCos(VectorDotProduct(AbsoluteUp, normalT2C));
    pitchNow := ClampValue(pitchNow + DegToRad(pitchDelta), 0 + 0.025, PI - 0.025);
    // create a new vector pointing up and then rotate it down
    // into the new position
    SetVector(normalT2C, AbsoluteUp);
    RotateVector(normalT2C, normalCameraRight, -pitchNow);
    RotateVector(normalT2C, AbsoluteUp, -DegToRadian(turnDelta));
    ScaleVector(normalT2C, dist);
    newPos := VectorAdd(AbsolutePosition, VectorSubtract(normalT2C, originalT2C));
    if assigned(Parent) then
      newPos          := Parent.AbsoluteToLocal(newPos);
    Position.AsVector := newPos;
  end;
end;

// MoveObjectAllAround
//

procedure TDGLBaseSceneObject.MoveObjectAllAround(anObject: TDGLBaseSceneObject; pitchDelta, turnDelta: Single);
var
  upVector:    TVector;
  lookat:      TVector;
  rightVector: TVector;
  tempvector:  TVector;
  T2C:         TVector;

begin

  // if camera has got a target
  if assigned(anObject) then
  begin
    // vector camera to target
    lookat := VectorNormalize(VectorSubtract(anObject.AbsolutePosition, AbsolutePosition));
    // camera up vector
    upVector := VectorNormalize(AbsoluteUp);

    // if upvector and lookat vector are colinear, it is necessary to compute new up vector
    if Abs(VectorDotProduct(lookat, upVector)) > 0.99 then
    begin
      // X or Y vector use to generate upvector
      SetVector(tempvector, 1, 0, 0);
      // if lookat is colinear to X vector use Y vector to generate upvector
      if Abs(VectorDotProduct(tempvector, lookat)) > 0.99 then
      begin
        SetVector(tempvector, 0, 1, 0);
      end;
      upVector    := VectorCrossProduct(tempvector, lookat);
      rightVector := VectorCrossProduct(lookat, upVector);
    end
    else
    begin
      rightVector := VectorCrossProduct(lookat, upVector);
      upVector    := VectorCrossProduct(rightVector, lookat);
    end;
    // now the up right and lookat vector are orthogonal

    // vector Target to camera
    T2C := VectorSubtract(AbsolutePosition, anObject.AbsolutePosition);
    RotateVector(T2C, rightVector, DegToRadian(-pitchDelta));
    RotateVector(T2C, upVector, DegToRadian(-turnDelta));
    AbsolutePosition := VectorAdd(anObject.AbsolutePosition, T2C);

    // now update new up vector
    RotateVector(upVector, rightVector, DegToRadian(-pitchDelta));
    AbsoluteUp        := upVector;
    AbsoluteDirection := VectorSubtract(anObject.AbsolutePosition, AbsolutePosition);

  end;
end;

// CoordinateChanged
//

procedure TDGLBaseSceneObject.CoordinateChanged(Sender: TDGLCustomCoordinates);
var
  rightVector: TVector;
begin
  if FIsCalculating then
    Exit;
  FIsCalculating := True;
  try
    if Sender = FDirection then
    begin
      if FDirection.VectorLength = 0 then
        FDirection.DirectVector := ZHmgVector;
      FDirection.Normalize;
      // adjust up vector
      rightVector := VectorCrossProduct(FDirection.AsVector, FUp.AsVector);
      // Rightvector is zero if direction changed exactly by 90 degrees,
      // in this case assume a default vector
      if VectorLength(rightVector) < 1E-5 then
      begin
        rightVector := VectorCrossProduct(ZHmgVector, FUp.AsVector);
        if VectorLength(rightVector) < 1E-5 then
          rightVector := VectorCrossProduct(XHmgVector, FUp.AsVector);
      end;
      FUp.DirectVector := VectorCrossProduct(rightVector, FDirection.AsVector);
      FUp.Normalize;
    end
    else if Sender = FUp then
    begin
      if FUp.VectorLength = 0 then
        FUp.DirectVector := YHmgVector;
      FUp.Normalize;
      // adjust up vector
      rightVector := VectorCrossProduct(FDirection.AsVector, FUp.AsVector);
      // Rightvector is zero if direction changed exactly by 90 degrees,
      // in this case assume a default vector
      if VectorLength(rightVector) < 1E-5 then
      begin
        rightVector := VectorCrossProduct(ZHmgVector, FUp.AsVector);
        if VectorLength(rightVector) < 1E-5 then
          rightVector := VectorCrossProduct(XHmgVector, FUp.AsVector);
      end;
      FDirection.DirectVector := VectorCrossProduct(FUp.AsVector, rightVector);
      FDirection.Normalize;
    end;
    TransformationChanged;
  finally
    FIsCalculating := False;
  end;
end;

// DoProgress
//

procedure TDGLBaseSceneObject.DoProgress(const progressTime: TProgressTimes);
var
  i: Integer;
begin
  if assigned(FChildren) then
    for i := FChildren.Count - 1 downto 0 do
      TDGLBaseSceneObject(FChildren.List^[i]).DoProgress(progressTime);
  if assigned(FGLBehaviours) then
    FGLBehaviours.DoProgress(progressTime);
  if assigned(FGLObjectEffects) then
    FGLObjectEffects.DoProgress(progressTime);
  if assigned(FOnProgress) then
    with progressTime do
      FOnProgress(Self, deltaTime, newTime);
end;

// Insert
//

procedure TDGLBaseSceneObject.Insert(AIndex: Integer; AChild: TDGLBaseSceneObject);
begin
  if not assigned(FChildren) then
    FChildren := TPersistentObjectList.Create;
  with FChildren do
  begin
    if assigned(AChild.FParent) then
      AChild.FParent.Remove(AChild, False);
    Insert(AIndex, AChild);
  end;
  AChild.FParent := Self;
  if AChild.FScene <> FScene then
    AChild.DestroyHandles;
  AChild.SetScene(FScene);
  if assigned(FScene) then
    FScene.AddLights(AChild);
  AChild.TransformationChanged;

  AChild.DoOnAddedToParent;
end;

// Remove
//

procedure TDGLBaseSceneObject.Remove(AChild: TDGLBaseSceneObject; keepChildren: Boolean);
var
  i: Integer;
begin
  if not assigned(FChildren) then
    Exit;
  if AChild.Parent = Self then
  begin
    if assigned(FScene) then
      FScene.RemoveLights(AChild);
    if AChild.Owner = Self then
      RemoveComponent(AChild);
    FChildren.Remove(AChild);
    AChild.FParent := nil;
    if keepChildren then
    begin
      BeginUpdate;
      if AChild.Count <> 0 then
        for i := AChild.Count - 1 downto 0 do
          if not IsSubComponent(AChild.Children[i]) then
            AChild.Children[i].MoveTo(Self);
      EndUpdate;
    end
    else
      NotifyChange(Self);
  end;
end;

// IndexOfChild
//

function TDGLBaseSceneObject.IndexOfChild(AChild: TDGLBaseSceneObject): Integer;
begin
  if assigned(FChildren) then
    Result := FChildren.IndexOf(AChild)
  else
    Result := -1;
end;

// FindChild
//

function TDGLBaseSceneObject.FindChild(const aName: string; ownChildrenOnly: Boolean): TDGLBaseSceneObject;
var
  i:   Integer;
  res: TDGLBaseSceneObject;
begin
  res    := nil;
  Result := nil;
  if not assigned(FChildren) then
    Exit;
  for i := 0 to FChildren.Count - 1 do
  begin
    if CompareText(TDGLBaseSceneObject(FChildren[i]).Name, aName) = 0 then
    begin
      res := TDGLBaseSceneObject(FChildren[i]);
      Break;
    end;
  end;
  if not ownChildrenOnly then
  begin
    for i := 0 to FChildren.Count - 1 do
      with TDGLBaseSceneObject(FChildren[i]) do
      begin
        Result := FindChild(aName, ownChildrenOnly);
        if assigned(Result) then
          Break;
      end;
  end;
  if not assigned(Result) then
    Result := res;
end;

// ExchangeChildren
//

procedure TDGLBaseSceneObject.ExchangeChildren(anIndex1, anIndex2: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  FChildren.Exchange(anIndex1, anIndex2);
  NotifyChange(Self);
end;

// ExchangeChildrenSafe
//

procedure TDGLBaseSceneObject.ExchangeChildrenSafe(anIndex1, anIndex2: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  if (anIndex1 < FChildren.Count) and (anIndex2 < FChildren.Count) and (anIndex1 > -1) and (anIndex2 > -1) and (anIndex1 <> anIndex2) then
  begin
    FChildren.Exchange(anIndex1, anIndex2);
    NotifyChange(Self);
  end;
end;

// MoveChildUp
//

procedure TDGLBaseSceneObject.MoveChildUp(anIndex: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  if anIndex > 0 then
  begin
    FChildren.Exchange(anIndex, anIndex - 1);
    NotifyChange(Self);
  end;
end;

// MoveChildDown
//

procedure TDGLBaseSceneObject.MoveChildDown(anIndex: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  if anIndex < FChildren.Count - 1 then
  begin
    FChildren.Exchange(anIndex, anIndex + 1);
    NotifyChange(Self);
  end;
end;

// MoveChildFirst
//

procedure TDGLBaseSceneObject.MoveChildFirst(anIndex: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  if anIndex <> 0 then
  begin
    FChildren.Move(anIndex, 0);
    NotifyChange(Self);
  end;
end;

// MoveChildLast
//

procedure TDGLBaseSceneObject.MoveChildLast(anIndex: Integer);
begin
  Assert(assigned(FChildren), 'No children found!');
  if anIndex <> FChildren.Count - 1 then
  begin
    FChildren.Move(anIndex, FChildren.Count - 1);
    NotifyChange(Self);
  end;
end;

// Render
//

procedure TDGLBaseSceneObject.Render(var ARci: TRenderContextInfo);
var
  shouldRenderSelf, shouldRenderChildren: Boolean;
  aabb:                                   TAABB;
  master:                                 TObject;
begin
  {$IFDEF GLS_OPENGL_DEBUG}
  if GL.GREMEDY_string_marker then
    GL.StringMarkerGREMEDY(Length(Name) + Length('.Render'), PGLChar(TGLString(Name + '.Render')));
  {$ENDIF}
  if (ARci.drawState = dsPicking) and not FPickable then
    Exit;
  // visibility culling determination
  if ARci.VisibilityCulling in [vcObjectBased, vcHierarchical] then
  begin
    if ARci.VisibilityCulling = vcObjectBased then
    begin
      shouldRenderSelf     := (osNoVisibilityCulling in ObjectStyle) or (not IsVolumeClipped(BarycenterAbsolutePosition, BoundingSphereRadius, ARci.rcci.frustum));
      shouldRenderChildren := assigned(FChildren);
    end
    else
    begin // vcHierarchical
      aabb                 := AxisAlignedBoundingBox;
      shouldRenderSelf     := (osNoVisibilityCulling in ObjectStyle) or (not IsVolumeClipped(aabb.min, aabb.max, ARci.rcci.frustum));
      shouldRenderChildren := shouldRenderSelf and assigned(FChildren);
    end;
    if not(shouldRenderSelf or shouldRenderChildren) then
      Exit;
  end
  else
  begin
    Assert(ARci.VisibilityCulling in [vcNone, vcInherited], 'Unknown visibility culling option');
    shouldRenderSelf     := True;
    shouldRenderChildren := assigned(FChildren);
  end;

  // Prepare Matrix and PickList stuff
  ARci.PipelineTransformation.Push;
  if ocTransformation in FChanges then
    RebuildMatrix;

  if ARci.proxySubObject then
    ARci.PipelineTransformation.ModelMatrix := MatrixMultiply(LocalMatrix^, ARci.PipelineTransformation.ModelMatrix)
  else
    ARci.PipelineTransformation.ModelMatrix := AbsoluteMatrix;

  master := nil;
  if ARci.drawState = dsPicking then
  begin
    if ARci.proxySubObject then
      master  := TDGLSceneBuffer(ARci.buffer).FSelector.CurrentObject;
    TDGLSceneBuffer(ARci.buffer).FSelector.CurrentObject := Self;
  end;

  // Start rendering
  if shouldRenderSelf then
  begin
    vCurrentRenderingObject := Self;
    {$IFNDEF GLS_OPTIMIZATIONS}
    if FShowAxes then
      DrawAxes(ARci, $CCCC);
    {$ENDIF}
    if assigned(FGLObjectEffects) and (FGLObjectEffects.Count > 0) then
    begin
      ARci.PipelineTransformation.Push;
      FGLObjectEffects.RenderPreEffects(ARci);
      ARci.PipelineTransformation.Pop;

      ARci.PipelineTransformation.Push;
      if osIgnoreDepthBuffer in ObjectStyle then
      begin
        ARci.GLStates.Disable(stDepthTest);
        DoRender(ARci, True, shouldRenderChildren);
        ARci.GLStates.Enable(stDepthTest);
      end
      else
        DoRender(ARci, True, shouldRenderChildren);

      FGLObjectEffects.RenderPostEffects(ARci);
      ARci.PipelineTransformation.Pop;
    end
    else
    begin
      if osIgnoreDepthBuffer in ObjectStyle then
      begin
        ARci.GLStates.Disable(stDepthTest);
        DoRender(ARci, True, shouldRenderChildren);
        ARci.GLStates.Enable(stDepthTest);
      end
      else
        DoRender(ARci, True, shouldRenderChildren);

    end;
    vCurrentRenderingObject := nil;
  end
  else
  begin
    if (osIgnoreDepthBuffer in ObjectStyle) and TDGLSceneBuffer(ARci.buffer).DepthTest then
    begin
      ARci.GLStates.Disable(stDepthTest);
      DoRender(ARci, False, shouldRenderChildren);
      ARci.GLStates.Enable(stDepthTest);
    end
    else
      DoRender(ARci, False, shouldRenderChildren);
  end;
  // Pop Name & Matrix
  if assigned(master) then
    TDGLSceneBuffer(ARci.buffer).FSelector.CurrentObject := master;
  ARci.PipelineTransformation.Pop;
end;

// DoRender
//

procedure TDGLBaseSceneObject.DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean);
begin
  // start rendering self
  if ARenderSelf then
  begin
    if (osDirectDraw in ObjectStyle) or ARci.amalgamating then
      BuildList(ARci)
    else
      ARci.GLStates.CallList(GetHandle(ARci));
  end;
  // start rendering children (if any)
  if ARenderChildren then
    Self.RenderChildren(0, Count - 1, ARci);
end;

// RenderChildren
//

procedure TDGLBaseSceneObject.RenderChildren(firstChildIndex, lastChildIndex: Integer; var rci: TRenderContextInfo);
var
  i:          Integer;
  objList:    TPersistentObjectList;
  distList:   TSingleList;
  plist:      PPointerObjectList;
  obj:        TDGLBaseSceneObject;
  oldSorting: TDGLObjectsSorting;
  oldCulling: TDGLVisibilityCulling;
begin
  if not assigned(FChildren) then
    Exit;
  oldCulling := rci.VisibilityCulling;
  if Self.VisibilityCulling <> vcInherited then
    rci.VisibilityCulling := Self.VisibilityCulling;
  if lastChildIndex = firstChildIndex then
  begin
    obj := TDGLBaseSceneObject(FChildren.List^[firstChildIndex]);
    if obj.Visible then
      obj.Render(rci)
  end
  else if lastChildIndex > firstChildIndex then
  begin
    oldSorting := rci.ObjectsSorting;
    if Self.ObjectsSorting <> osInherited then
      rci.ObjectsSorting := Self.ObjectsSorting;
    case rci.ObjectsSorting of
      osNone:
        begin
          plist := FChildren.List;
          for i := firstChildIndex to lastChildIndex do
          begin
            obj := TDGLBaseSceneObject(plist^[i]);
            if obj.Visible then
              obj.Render(rci);
          end;
        end;
      osRenderFarthestFirst, osRenderBlendedLast, osRenderNearestFirst:
        begin
          distList             := TSingleList.Create;
          objList              := TPersistentObjectList.Create;
          distList.GrowthDelta := lastChildIndex + 1; // no reallocations
          objList.GrowthDelta  := distList.GrowthDelta;
          try
            case rci.ObjectsSorting of
              osRenderBlendedLast:
                // render opaque stuff
                for i := firstChildIndex to lastChildIndex do
                begin
                  obj := TDGLBaseSceneObject(FChildren.List^[i]);
                  if obj.Visible then
                  begin
                    if not obj.Blended then
                      obj.Render(rci)
                    else
                    begin
                      objList.Add(obj);
                      distList.Add(1 + obj.BarycenterSqrDistanceTo(rci.cameraPosition));
                    end;
                  end;
                end;
              osRenderFarthestFirst:
                for i := firstChildIndex to lastChildIndex do
                begin
                  obj := TDGLBaseSceneObject(FChildren.List^[i]);
                  if obj.Visible then
                  begin
                    objList.Add(obj);
                    distList.Add(1 + obj.BarycenterSqrDistanceTo(rci.cameraPosition));
                  end;
                end;
              osRenderNearestFirst:
                for i := firstChildIndex to lastChildIndex do
                begin
                  obj := TDGLBaseSceneObject(FChildren.List^[i]);
                  if obj.Visible then
                  begin
                    objList.Add(obj);
                    distList.Add(-1 - obj.BarycenterSqrDistanceTo(rci.cameraPosition));
                  end;
                end;
            else
              Assert(False);
            end;
            if distList.Count > 0 then
            begin
              if distList.Count > 1 then
                FastQuickSortLists(0, distList.Count - 1, distList, objList);
              plist := objList.List;
              for i := objList.Count - 1 downto 0 do
                TDGLBaseSceneObject(plist^[i]).Render(rci);
            end;
          finally
            objList.Free;
            distList.Free;
          end;
        end;
    else
      Assert(False);
    end;
    rci.ObjectsSorting := oldSorting;
  end;
  rci.VisibilityCulling := oldCulling;
end;

// NotifyChange
//

procedure TDGLBaseSceneObject.NotifyChange(Sender: TObject);
begin
  if assigned(FScene) and (not IsUpdating) then
    FScene.NotifyChange(Self);
end;

// GetMatrix
//

function TDGLBaseSceneObject.GetMatrix: TMatrix;
begin
  RebuildMatrix;
  Result := FLocalMatrix^;
end;

// MatrixAsAddress
//

function TDGLBaseSceneObject.MatrixAsAddress: PMatrix;
begin
  RebuildMatrix;
  Result := FLocalMatrix;
end;

// SetMatrix
//

procedure TDGLBaseSceneObject.SetMatrix(const aValue: TMatrix);
begin
  FLocalMatrix^           := aValue;
  FDirection.DirectVector := VectorNormalize(FLocalMatrix^.v[2]);
  FUp.DirectVector        := VectorNormalize(FLocalMatrix^.v[1]);
  Scale.SetVector(VectorLength(FLocalMatrix^.v[0]), VectorLength(FLocalMatrix^.v[1]), VectorLength(FLocalMatrix^.v[2]), 0);
  FPosition.DirectVector := FLocalMatrix^.v[3];
  TransformationChanged;
end;

procedure TDGLBaseSceneObject.SetPosition(APosition: TDGLCoordinates);
begin
  FPosition.SetPoint(APosition.DirectX, APosition.DirectY, APosition.DirectZ);
end;

procedure TDGLBaseSceneObject.SetDirection(AVector: TDGLCoordinates);
begin
  if not VectorIsNull(AVector.DirectVector) then
    FDirection.SetVector(AVector.DirectX, AVector.DirectY, AVector.DirectZ);
end;

procedure TDGLBaseSceneObject.SetUp(AVector: TDGLCoordinates);
begin
  if not VectorIsNull(AVector.DirectVector) then
    FUp.SetVector(AVector.DirectX, AVector.DirectY, AVector.DirectZ);
end;

function TDGLBaseSceneObject.GetVisible: Boolean;
begin
  Result := FVisible;
end;

function TDGLBaseSceneObject.GetPickable: Boolean;
begin
  Result := FPickable;
end;

// SetVisible
//

procedure TDGLBaseSceneObject.SetVisible(aValue: Boolean);
begin
  if FVisible <> aValue then
  begin
    FVisible := aValue;
    NotifyChange(Self);
  end;
end;

// SetPickable
//

procedure TDGLBaseSceneObject.SetPickable(aValue: Boolean);
begin
  if FPickable <> aValue then
  begin
    FPickable := aValue;
    NotifyChange(Self);
  end;
end;

// SetObjectsSorting
//

procedure TDGLBaseSceneObject.SetObjectsSorting(const val: TDGLObjectsSorting);
begin
  if FObjectsSorting <> val then
  begin
    FObjectsSorting := val;
    NotifyChange(Self);
  end;
end;

// SetVisibilityCulling
//

procedure TDGLBaseSceneObject.SetVisibilityCulling(const val: TGLVisibilityCulling);
begin
  if FVisibilityCulling <> val then
  begin
    FVisibilityCulling := val;
    NotifyChange(Self);
  end;
end;

// SetBehaviours
//

procedure TDGLBaseSceneObject.SetBehaviours(const val: TGLBehaviours);
begin
  Behaviours.Assign(val);
end;

// GetBehaviours
//

function TDGLBaseSceneObject.GetBehaviours: TGLBehaviours;
begin
  if not assigned(FGLBehaviours) then
    FGLBehaviours := TGLBehaviours.Create(Self);
  Result          := FGLBehaviours;
end;

// SetEffects
//

procedure TDGLBaseSceneObject.SetEffects(const val: TGLObjectEffects);
begin
  Effects.Assign(val);
end;

// GetEffects
//

function TDGLBaseSceneObject.GetEffects: TGLObjectEffects;
begin
  if not assigned(FGLObjectEffects) then
    FGLObjectEffects := TGLObjectEffects.Create(Self);
  Result             := FGLObjectEffects;
end;

// SetScene
//

procedure TDGLBaseSceneObject.SetScene(const Value: TDGLScene);
var
  i: Integer;
begin
  if Value <> FScene then
  begin
    // must be freed, the new scene may be using a non-compatible RC
    if FScene <> nil then
      DestroyHandles;
    FScene := Value;
    // propagate for childs
    if assigned(FChildren) then
      for i := 0 to FChildren.Count - 1 do
        Children[i].SetScene(FScene);
  end;
end;

// Translate
//

procedure TDGLBaseSceneObject.Translate(tx, ty, tz: Single);
begin
  FPosition.Translate(AffineVectorMake(tx, ty, tz));
end;

// GetAbsoluteAffinePosition
//

function TDGLBaseSceneObject.GetAbsoluteAffinePosition: TAffineVector;
var
  temp: TVector;
begin
  temp   := GetAbsolutePosition;
  Result := AffineVectorMake(temp.v[0], temp.v[1], temp.v[2]);
end;

// GetAbsoluteAffineDirection
//

function TDGLBaseSceneObject.GetAbsoluteAffineDirection: TAffineVector;
var
  temp: TVector;
begin
  temp   := GetAbsoluteDirection;
  Result := AffineVectorMake(temp.v[0], temp.v[1], temp.v[2]);
end;

// GetAbsoluteAffineUp
//

function TDGLBaseSceneObject.GetAbsoluteAffineUp: TAffineVector;
var
  temp: TVector;
begin
  temp   := GetAbsoluteUp;
  Result := AffineVectorMake(temp.v[0], temp.v[1], temp.v[2]);
end;

// SetAbsoluteAffinePosition
//

procedure TDGLBaseSceneObject.SetAbsoluteAffinePosition(const Value: TAffineVector);
begin
  SetAbsolutePosition(VectorMake(Value, 1));
end;

// SetAbsoluteAffineUp
//

procedure TDGLBaseSceneObject.SetAbsoluteAffineUp(const v: TAffineVector);
begin
  SetAbsoluteUp(VectorMake(v, 1));
end;

// SetAbsoluteAffineDirection
//

procedure TDGLBaseSceneObject.SetAbsoluteAffineDirection(const v: TAffineVector);
begin
  SetAbsoluteDirection(VectorMake(v, 1));
end;

// AffineLeftVector
//

function TDGLBaseSceneObject.AffineLeftVector: TAffineVector;
begin
  Result := AffineVectorMake(LeftVector);
end;

// AffineRight
//

function TDGLBaseSceneObject.AffineRight: TAffineVector;
begin
  Result := AffineVectorMake(Right);
end;

// DistanceTo
//

function TDGLBaseSceneObject.DistanceTo(const pt: TAffineVector): Single;
begin
  Result := VectorDistance(AbsoluteAffinePosition, pt);
end;

// SqrDistanceTo
//

function TDGLBaseSceneObject.SqrDistanceTo(const pt: TAffineVector): Single;
begin
  Result := VectorDistance2(AbsoluteAffinePosition, pt);
end;

// DoOnAddedToParent
//

procedure TDGLBaseSceneObject.DoOnAddedToParent;
begin
  if assigned(FOnAddedToParent) then
    FOnAddedToParent(Self);
end;

// GetAbsoluteAffineScale
//

function TDGLBaseSceneObject.GetAbsoluteAffineScale: TAffineVector;
begin
  Result := AffineVectorMake(GetAbsoluteScale);
end;

// SetAbsoluteAffineScale
//

procedure TDGLBaseSceneObject.SetAbsoluteAffineScale(const Value: TAffineVector);
begin
  SetAbsoluteScale(VectorMake(Value, GetAbsoluteScale.v[3]));
end;



// ------------------
// ------------------ TDGLSceneRootObject ------------------
// ------------------

// Create
//

constructor TDGLSceneRootObject.Create(AOwner: TComponent);
begin
  Assert(AOwner is TDGLScene);
  inherited Create(AOwner);
  ObjectStyle := ObjectStyle + [osDirectDraw];
  FScene      := TDGLScene(AOwner);
end;


// ------------------
// ------------------ TGLBaseBehaviour ------------------
// ------------------

// Create
//

constructor TGLBaseBehaviour.Create(AOwner: TDGLXCollection);
begin
  inherited Create(AOwner);
  // nothing more, yet
end;

// Destroy
//

destructor TGLBaseBehaviour.Destroy;
begin
  // nothing more, yet
  inherited Destroy;
end;

// SetName
//

procedure TGLBaseBehaviour.SetName(const val: string);
begin
  inherited SetName(val);
  if assigned(vGLBehaviourNameChangeEvent) then
    vGLBehaviourNameChangeEvent(Self);
end;

// WriteToFiler
//

procedure TGLBaseBehaviour.WriteToFiler(writer: TWriter);
begin
  inherited;

  with writer do
  begin
    WriteInteger(0); // Archive Version 0
    // nothing more, yet
  end;
end;

// ReadFromFiler
//

procedure TGLBaseBehaviour.ReadFromFiler(reader: TReader);
begin
  if Owner.ArchiveVersion > 0 then
    inherited;

  with reader do
  begin
    if ReadInteger <> 0 then
      Assert(False);
    // nothing more, yet
  end;
end;

// OwnerBaseSceneObject
//

function TGLBaseBehaviour.OwnerBaseSceneObject: TDGLBaseSceneObject;
begin
  Result := TDGLBaseSceneObject(Owner.Owner);
end;

// DoProgress
//

procedure TGLBaseBehaviour.DoProgress(const progressTime: TProgressTimes);
begin
  // does nothing
end;

// ------------------
// ------------------ TGLBehaviours ------------------
// ------------------

// Create
//

constructor TGLBehaviours.Create(AOwner: TPersistent);
begin
  Assert(AOwner is TDGLBaseSceneObject);
  inherited Create(AOwner);
end;

// GetNamePath
//

function TGLBehaviours.GetNamePath: string;
var
  s: string;
begin
  Result := ClassName;
  if GetOwner = nil then
    Exit;
  s := GetOwner.GetNamePath;
  if s = '' then
    Exit;
  Result := s + '.Behaviours';
end;

// ItemsClass
//

class function TGLBehaviours.ItemsClass: TDGLXCollectionItemClass;
begin
  Result := TGLBehaviour;
end;

// GetBehaviour
//

function TGLBehaviours.GetBehaviour(Index: Integer): TGLBehaviour;
begin
  Result := TGLBehaviour(Items[index]);
end;

// CanAdd
//

function TGLBehaviours.CanAdd(aClass: TDGLXCollectionItemClass): Boolean;
begin
  Result := (not aClass.InheritsFrom(TGLObjectEffect)) and (inherited CanAdd(aClass));
end;

// DoProgress
//

procedure TGLBehaviours.DoProgress(const progressTimes: TProgressTimes);
var
  i: Integer;
begin
  for i := 0 to Count - 1 do
    TGLBehaviour(Items[i]).DoProgress(progressTimes);
end;

// ------------------
// ------------------ TGLObjectEffect ------------------
// ------------------

// WriteToFiler
//

procedure TGLObjectEffect.WriteToFiler(writer: TWriter);
begin
  inherited;
  with writer do
  begin
    WriteInteger(0); // Archive Version 0
    // nothing more, yet
  end;
end;

// ReadFromFiler
//

procedure TGLObjectEffect.ReadFromFiler(reader: TReader);
begin
  if Owner.ArchiveVersion > 0 then
    inherited;

  with reader do
  begin
    if ReadInteger <> 0 then
      Assert(False);
    // nothing more, yet
  end;
end;

// Render
//

procedure TGLObjectEffect.Render(var rci: TRenderContextInfo);
begin
  // nothing here, this implem is just to avoid "abstract error"
end;

// ------------------
// ------------------ TGLObjectEffects ------------------
// ------------------

// Create
//

constructor TGLObjectEffects.Create(AOwner: TPersistent);
begin
  Assert(AOwner is TDGLBaseSceneObject);
  inherited Create(AOwner);
end;

// GetNamePath
//

function TGLObjectEffects.GetNamePath: string;
var
  s: string;
begin
  Result := ClassName;
  if GetOwner = nil then
    Exit;
  s := GetOwner.GetNamePath;
  if s = '' then
    Exit;
  Result := s + '.Effects';
end;

// ItemsClass
//

class function TGLObjectEffects.ItemsClass: TDGLXCollectionItemClass;
begin
  Result := TGLObjectEffect;
end;

// GetEffect
//

function TGLObjectEffects.GetEffect(Index: Integer): TGLObjectEffect;
begin
  Result := TGLObjectEffect(Items[index]);
end;

// CanAdd
//

function TGLObjectEffects.CanAdd(aClass: TDGLXCollectionItemClass): Boolean;
begin
  Result := (aClass.InheritsFrom(TGLObjectEffect)) and (inherited CanAdd(aClass));
end;

// DoProgress
//

procedure TGLObjectEffects.DoProgress(const progressTime: TProgressTimes);
var
  i: Integer;
begin
  for i := 0 to Count - 1 do
    TGLObjectEffect(Items[i]).DoProgress(progressTime);
end;

// RenderPreEffects
//

procedure TGLObjectEffects.RenderPreEffects(var rci: TRenderContextInfo);
var
  i:      Integer;
  effect: TGLObjectEffect;
begin
  for i := 0 to Count - 1 do
  begin
    effect := TGLObjectEffect(Items[i]);
    if effect is TGLObjectPreEffect then
      effect.Render(rci);
  end;
end;

// RenderPostEffects
//

procedure TGLObjectEffects.RenderPostEffects(var rci: TRenderContextInfo);
var
  i:      Integer;
  effect: TGLObjectEffect;
begin
  for i := 0 to Count - 1 do
  begin
    effect := TGLObjectEffect(Items[i]);
    if effect is TGLObjectPostEffect then
      effect.Render(rci)
    else if assigned(rci.afterRenderEffects) and (effect is TGLObjectAfterEffect) then
      rci.afterRenderEffects.Add(effect);
  end;
end;

// ------------------
// ------------------ TGLCustomSceneObject ------------------
// ------------------

// Create
//

constructor TGLCustomSceneObject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FMaterial := TGLMaterial.Create(Self);
end;

// Destroy
//

destructor TGLCustomSceneObject.Destroy;
begin
  inherited Destroy;
  FMaterial.Free;
end;

// Assign
//

procedure TGLCustomSceneObject.Assign(Source: TPersistent);
begin
  if Source is TGLCustomSceneObject then
  begin
    FMaterial.Assign(TGLCustomSceneObject(Source).FMaterial);
    FHint := TGLCustomSceneObject(Source).FHint;
  end;
  inherited Assign(Source);
end;

// Blended
//

function TGLCustomSceneObject.Blended: Boolean;
begin
  Result := Material.Blended;
end;

// Loaded
//

procedure TGLCustomSceneObject.Loaded;
begin
  inherited;
  FMaterial.Loaded;
end;

// SetGLMaterial
//

procedure TGLCustomSceneObject.SetGLMaterial(aValue: TGLMaterial);
begin
  FMaterial.Assign(aValue);
  NotifyChange(Self);
end;

// DestroyHandle
//

procedure TGLCustomSceneObject.DestroyHandle;
begin
  inherited;
  FMaterial.DestroyHandles;
end;

// DoRender
//

procedure TGLCustomSceneObject.DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean);
begin
  // start rendering self
  if ARenderSelf then
    if ARci.ignoreMaterials then
      if (osDirectDraw in ObjectStyle) or ARci.amalgamating then
        BuildList(ARci)
      else
        ARci.GLStates.CallList(GetHandle(ARci))
    else
    begin
      FMaterial.Apply(ARci);
      repeat
        if (osDirectDraw in ObjectStyle) or ARci.amalgamating then
          BuildList(ARci)
        else
          ARci.GLStates.CallList(GetHandle(ARci));
      until not FMaterial.UnApply(ARci);
    end;
  // start rendering children (if any)
  if ARenderChildren then
    Self.RenderChildren(0, Count - 1, ARci);
end;

// ------------------
// ------------------ TGLImmaterialSceneObject ------------------
// ------------------

// DoRender
//

procedure TGLImmaterialSceneObject.DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean);
begin
  // start rendering self
  if ARenderSelf then
  begin
    if (osDirectDraw in ObjectStyle) or ARci.amalgamating then
      BuildList(ARci)
    else
      ARci.GLStates.CallList(GetHandle(ARci));
  end;
  // start rendering children (if any)
  if ARenderChildren then
    Self.RenderChildren(0, Count - 1, ARci);
end;

// ------------------
// ------------------ TGLCameraInvariantObject ------------------
// ------------------

// Create
//

constructor TGLCameraInvariantObject.Create(AOwner: TComponent);
begin
  inherited;
  FCamInvarianceMode := cimNone;
end;

// Assign
//

procedure TGLCameraInvariantObject.Assign(Source: TPersistent);
begin
  if Source is TGLCameraInvariantObject then
  begin
    FCamInvarianceMode := TGLCameraInvariantObject(Source).FCamInvarianceMode;
  end;
  inherited Assign(Source);
end;

// DoRender
//

procedure TGLCameraInvariantObject.DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean);
begin
  if CamInvarianceMode <> cimNone then
    with ARci.PipelineTransformation do
    begin
      Push;
      try
        // prepare
        case CamInvarianceMode of
          cimPosition:
            begin
              ViewMatrix := MatrixMultiply(CreateTranslationMatrix(ARci.cameraPosition), ARci.PipelineTransformation.ViewMatrix);
            end;
          cimOrientation:
            begin
              // makes the coordinates system more 'intuitive' (Z+ forward)
              ViewMatrix := CreateScaleMatrix(Vector3fMake(1, -1, -1))
            end;
        else
          Assert(False);
        end;
        // Apply local transform
        ModelMatrix := LocalMatrix^;

        if ARenderSelf then
        begin
          if (osDirectDraw in ObjectStyle) or ARci.amalgamating then
            BuildList(ARci)
          else
            ARci.GLStates.CallList(GetHandle(ARci));
        end;
        if ARenderChildren then
          Self.RenderChildren(0, Count - 1, ARci);
      finally
        Pop;
      end;
    end
  else
    inherited;
end;

// SetCamInvarianceMode
//

procedure TGLCameraInvariantObject.SetCamInvarianceMode(const val: TGLCameraInvarianceMode);
begin
  if FCamInvarianceMode <> val then
  begin
    FCamInvarianceMode := val;
    NotifyChange(Self);
  end;
end;

// ------------------
// ------------------ TGLRenderPoint ------------------
// ------------------

// Create
//

constructor TGLRenderPoint.Create(AOwner: TComponent);
begin
  inherited;
  ObjectStyle := ObjectStyle + [osDirectDraw];
end;

// Destroy
//

destructor TGLRenderPoint.Destroy;
begin
  Clear;
  inherited;
end;

// BuildList
//

procedure TGLRenderPoint.BuildList(var rci: TRenderContextInfo);
var
  i: Integer;
begin
  for i := 0 to High(FCallBacks) do
    FCallBacks[i](Self, rci);
end;

// RegisterCallBack
//

procedure TGLRenderPoint.RegisterCallBack(renderEvent: TDirectRenderEvent; renderPointFreed: TNotifyEvent);
var
  n: Integer;
begin
  n := Length(FCallBacks);
  SetLength(FCallBacks, n + 1);
  SetLength(FFreeCallBacks, n + 1);
  FCallBacks[n]     := renderEvent;
  FFreeCallBacks[n] := renderPointFreed;
end;

// UnRegisterCallBack
//

procedure TGLRenderPoint.UnRegisterCallBack(renderEvent: TDirectRenderEvent);
type
  TEventContainer = record
    event: TDirectRenderEvent;
  end;
var
  i, j, n:                     Integer;
  refContainer, listContainer: TEventContainer;
begin
  refContainer.event := renderEvent;
  n                  := Length(FCallBacks);
  for i              := 0 to n - 1 do
  begin
    listContainer.event := FCallBacks[i];
    if CompareMem(@listContainer, @refContainer, SizeOf(TEventContainer)) then
    begin
      for j := i + 1 to n - 1 do
      begin
        FCallBacks[j - 1]     := FCallBacks[j];
        FFreeCallBacks[j - 1] := FFreeCallBacks[j];
      end;
      SetLength(FCallBacks, n - 1);
      SetLength(FFreeCallBacks, n - 1);
      Break;
    end;
  end;
end;

// BuildList
//

procedure TGLRenderPoint.Clear;
begin
  while Length(FCallBacks) > 0 do
  begin
    FFreeCallBacks[High(FCallBacks)](Self);
    SetLength(FCallBacks, Length(FCallBacks) - 1);
  end;
end;

// ------------------
// ------------------ TGLProxyObject ------------------
// ------------------

// Create
//

constructor TGLProxyObject.Create(AOwner: TComponent);
begin
  inherited;
  FProxyOptions := cDefaultProxyOptions;
end;

// Destroy
//

destructor TGLProxyObject.Destroy;
begin
  SetMasterObject(nil);
  inherited;
end;

// Assign
//

procedure TGLProxyObject.Assign(Source: TPersistent);
begin
  if Source is TGLProxyObject then
  begin
    SetMasterObject(TGLProxyObject(Source).MasterObject);
  end;
  inherited Assign(Source);
end;

// Render
//

procedure TGLProxyObject.DoRender(var ARci: TRenderContextInfo; ARenderSelf, ARenderChildren: Boolean);
var
  gotMaster, masterGotEffects, oldProxySubObject: Boolean;
begin
  if FRendering then
    Exit;
  FRendering := True;
  try
    gotMaster        := assigned(FMasterObject);
    masterGotEffects := gotMaster and (pooEffects in FProxyOptions) and (FMasterObject.Effects.Count > 0);
    if gotMaster then
    begin
      if pooObjects in FProxyOptions then
      begin
        oldProxySubObject   := ARci.proxySubObject;
        ARci.proxySubObject := True;
        if pooTransformation in FProxyOptions then
          with ARci.PipelineTransformation do
            ModelMatrix := MatrixMultiply(FMasterObject.Matrix, ModelMatrix);
        FMasterObject.DoRender(ARci, ARenderSelf, (FMasterObject.Count > 0));
        ARci.proxySubObject := oldProxySubObject;
      end;
    end;
    // now render self stuff (our children, our effects, etc.)
    if ARenderChildren and (Count > 0) then
      Self.RenderChildren(0, Count - 1, ARci);
    if masterGotEffects then
      FMasterObject.Effects.RenderPostEffects(ARci);
  finally
    FRendering := False;
  end;
  ClearStructureChanged;
end;

// AxisAlignedDimensions
//

function TGLProxyObject.AxisAlignedDimensions: TVector;
begin
  If assigned(FMasterObject) then
  begin
    Result := FMasterObject.AxisAlignedDimensionsUnscaled;
    If (pooTransformation in ProxyOptions) then
      ScaleVector(Result, FMasterObject.Scale.AsVector)
    else
      ScaleVector(Result, Scale.AsVector);
  end
  else
    Result := inherited AxisAlignedDimensions;
end;

function TGLProxyObject.AxisAlignedDimensionsUnscaled: TVector;
begin
  if assigned(FMasterObject) then
  begin
    Result := FMasterObject.AxisAlignedDimensionsUnscaled;
  end
  else
    Result := inherited AxisAlignedDimensionsUnscaled;
end;

// BarycenterAbsolutePosition
//

function TGLProxyObject.BarycenterAbsolutePosition: TVector;
var
  lAdjustVector: TVector;
begin
  if assigned(FMasterObject) then
  begin
    // Not entirely correct, but better than nothing...
    lAdjustVector     := VectorSubtract(FMasterObject.BarycenterAbsolutePosition, FMasterObject.AbsolutePosition);
    Position.AsVector := VectorAdd(Position.AsVector, lAdjustVector);
    Result            := AbsolutePosition;
    Position.AsVector := VectorSubtract(Position.AsVector, lAdjustVector);
  end
  else
    Result := inherited BarycenterAbsolutePosition;
end;

// Notification
//

procedure TGLProxyObject.Notification(AComponent: TComponent; Operation: TOperation);
begin
  if (Operation = opRemove) and (AComponent = FMasterObject) then
    MasterObject := nil;
  inherited;
end;

// SetMasterObject
//

procedure TGLProxyObject.SetMasterObject(const val: TDGLBaseSceneObject);
begin
  if FMasterObject <> val then
  begin
    if assigned(FMasterObject) then
      FMasterObject.RemoveFreeNotification(Self);
    FMasterObject := val;
    if assigned(FMasterObject) then
      FMasterObject.FreeNotification(Self);
    StructureChanged;
  end;
end;

// SetProxyOptions
//

procedure TGLProxyObject.SetProxyOptions(const val: TGLProxyObjectOptions);
begin
  if FProxyOptions <> val then
  begin
    FProxyOptions := val;
    StructureChanged;
  end;
end;

// RayCastIntersect
//

function TGLProxyObject.RayCastIntersect(const rayStart, rayVector: TVector; intersectPoint: PVector = nil; intersectNormal: PVector = nil): Boolean;
var
  localRayStart, localRayVector: TVector;
begin
  if assigned(MasterObject) then
  begin
    SetVector(localRayStart, AbsoluteToLocal(rayStart));
    SetVector(localRayStart, MasterObject.LocalToAbsolute(localRayStart));
    SetVector(localRayVector, AbsoluteToLocal(rayVector));
    SetVector(localRayVector, MasterObject.LocalToAbsolute(localRayVector));
    NormalizeVector(localRayVector);

    Result := MasterObject.RayCastIntersect(localRayStart, localRayVector, intersectPoint, intersectNormal);
    if Result then
    begin
      if assigned(intersectPoint) then
      begin
        SetVector(intersectPoint^, MasterObject.AbsoluteToLocal(intersectPoint^));
        SetVector(intersectPoint^, LocalToAbsolute(intersectPoint^));
      end;
      if assigned(intersectNormal) then
      begin
        SetVector(intersectNormal^, MasterObject.AbsoluteToLocal(intersectNormal^));
        SetVector(intersectNormal^, LocalToAbsolute(intersectNormal^));
      end;
    end;
  end
  else
    Result := False;
end;

// GenerateSilhouette
//

function TGLProxyObject.GenerateSilhouette(const silhouetteParameters: TGLSilhouetteParameters): TGLSilhouette;
begin
  if assigned(MasterObject) then
    Result := MasterObject.GenerateSilhouette(silhouetteParameters)
  else
    Result := nil;
end;

end.
