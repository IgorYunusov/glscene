//
// VKScene Component Library, based on GLScene http://glscene.sourceforge.net 
//
{
   Extrusion objects for GLScene.  Extrusion objects are solids defined by the
   surface described by a moving curve. 
  
}
{  TODO

   ur:
     Suggestion:
       All extrusion objects use actually the same kind of "parts",
       one common type should do.
}
unit VKS.Extrusion;

interface

{$I VKScene.inc}

uses
  System.Classes,
  Winapi.OpenGL, Winapi.OpenGLext,   VKS.Context,  VKS.Objects,  VKS.Scene, VKS.MultiPolygon,
  VKS.Color, VKS.VectorGeometry, VKS.RenderContextInfo, VKS.Nodes,
  VKS.State, VKS.VectorTypes;

type

  TExtrusionSolidPart = (espOutside, espInside, espStartPolygon,
    espStopPolygon);
  TExtrusionSolidParts = set of TExtrusionSolidPart;

  // TRevolutionSolidParts
  //
  TRevolutionSolidPart = (rspOutside, rspInside, rspStartPolygon,
    rspStopPolygon);
  TRevolutionSolidParts = set of TRevolutionSolidPart;

  // TVKRevolutionSolid
  //
  { A solid object generated by rotating a curve along the Y axis. 
     The curve is described by the Nodes and SplineMode properties, and it is
     rotated in the trigonometrical direction (CCW when seen from Y->INF). 
     The TVKRevolutionSolid can also be used to render regular helicoidions, by
     setting a non-null YOffsetPerTurn, and adjusting start/finish angles to
     make more than one revolution. 
     If you want top/bottom caps, just add a first/last node that will make
     the curve start/finish on the Y axis. }
  TVKRevolutionSolid = class(TVKPolygonBase)
  private
    { Private Declarations }
    FSlices: Integer;
    FStartAngle, FStopAngle: Single;
    FNormals: TNormalSmoothing;
    FYOffsetPerTurn: Single;
    FTriangleCount: Integer;
    FNormalDirection: TNormalDirection;
    FParts: TRevolutionSolidParts;
    FAxisAlignedDimensionsCache: TVector;
  protected
    { Protected Declarations }
    procedure SetStartAngle(const val: Single);
    procedure SetStopAngle(const val: Single);
    function StoreStopAngle: Boolean;
    procedure SetSlices(const val: Integer);
    procedure SetNormals(const val: TNormalSmoothing);
    procedure SetYOffsetPerTurn(const val: Single);
    procedure SetNormalDirection(const val: TNormalDirection);
    procedure SetParts(const val: TRevolutionSolidParts);

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BuildList(var rci: TVKRenderContextInfo); override;

    { Number of triangles used for rendering. }
    property TriangleCount: Integer read FTriangleCount;
    function AxisAlignedDimensionsUnscaled: TVector; override;
    procedure StructureChanged; override;

  published
    { Published Declarations }
          { Parts of the rotation solid to be generated for rendering. 
             rspInside and rspOutside are generated from the curve and make the
             inside/outside as long as NormalDirection=ndOutside and the solid
             is described by the curve that goes from top to bottom. 
             Start/StopPolygon are tesselated from the curve (considered as closed). }
    property Parts: TRevolutionSolidParts read FParts write SetParts default
      [rspOutside];

    property StartAngle: Single read FStartAngle write SetStartAngle;
    property StopAngle: Single read FStopAngle write SetStopAngle stored
      StoreStopAngle;
    { Y offset applied to the curve position for each turn. 
       This amount is applied proportionnally, for instance if your curve
       is a small circle, off from the Y axis, with a YOffset set to 0 (zero),
       you will get a torus, but with a non null value, you will get a
       small helicoidal spring. 
       This can be useful for rendering, lots of helicoidal objects from
       screws, to nails to stairs etc. }
    property YOffsetPerTurn: Single read FYOffsetPerTurn write
      SetYOffsetPerTurn;
    { Number of slices per turn (360Щ. }
    property Slices: Integer read FSlices write SetSlices default 16;

    property Normals: TNormalSmoothing read FNormals write SetNormals default
      nsFlat;
    property NormalDirection: TNormalDirection read FNormalDirection write
      SetNormalDirection default ndOutside;
  end;

  // TVKExtrusionSolid
  //
  { Extrudes a complex Polygon into Z direction. 
    For contour description see TMultiPolygonBase. 
    properties Parts, Height (or should we better cal it Depth, because its in Z?),
    Stacks, Normals and NormalDirection are equivalent to TVKRevolutionSolid. 

    If Normals=nsSmooth and the angle between two consecutive normals along the
    contour is less than MinSmoothAngle, smoothing is done, otherweise flat normals
    are used. This makes it possible to have smooth normals on sharp edged contours.
  }
  TVKExtrusionSolid = class(TMultiPolygonBase)
  private
    { Private Declarations }
    FStacks: Integer;
    FNormals: TNormalSmoothing;
    FTriangleCount: Integer;
    FNormalDirection: TNormalDirection;
    FParts: TExtrusionSolidParts;
    FHeight: GLfloat;
    FMinSmoothAngle: Single;
    FMinSmoothAngleCos: Single;
    FAxisAlignedDimensionsCache: TVector;
    procedure SetHeight(const Value: GLfloat);
    procedure SetMinSmoothAngle(const Value: Single);

  protected
    { Protected Declarations }
    procedure SetStacks(const val: Integer);
    procedure SetNormals(const val: TNormalSmoothing);
    procedure SetNormalDirection(const val: TNormalDirection);
    procedure SetParts(const val: TExtrusionSolidParts);

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BuildList(var rci: TVKRenderContextInfo); override;

    { Number of triangles used for rendering. }
    property TriangleCount: Integer read FTriangleCount;
    function AxisAlignedDimensionsUnscaled: TVector; override;
    procedure StructureChanged; override;

  published
    { Published Declarations }
    property Parts: TExtrusionSolidParts read FParts write SetParts default
      [espOutside];

    property Height: GLfloat read FHeight write SetHeight;
    property Stacks: Integer read FStacks write SetStacks default 1;

    property Normals: TNormalSmoothing read FNormals write SetNormals default
      nsFlat;
    property NormalDirection: TNormalDirection read FNormalDirection write
      SetNormalDirection default ndOutside;
    property MinSmoothAngle: Single read FMinSmoothAngle write
      SetMinSmoothAngle;
  end;

  // TVKPipeNode
  //
  TVKPipeNode = class(TVKNode)
  private
    { Private Declarations }
    FRadiusFactor: Single;
    FColor: TVKColor;
    FTexCoordT: Single;

  protected
    { Protected Declarations }
    function GetDisplayName: string; override;
    procedure SetRadiusFactor(const val: Single);
    function StoreRadiusFactor: Boolean;
    procedure SetColor(const val: TVKColor);
    procedure ColorChanged(sender: TObject);
    function StoreTexCoordT: Boolean;
  public
    { Public Declarations }
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;

  published
    { Published Declarations }
    property RadiusFactor: Single read FRadiusFactor write SetRadiusFactor stored
      StoreRadiusFactor;
    property Color: TVKColor read FColor write SetColor;
    property TexCoordT: Single read FTexCoordT write FTexCoordT stored
      StoreTexCoordT;

  end;

  // TVKPipeNodes
  //
  TVKPipeNodes = class(TVKLinesNodes)
  protected
    { Protected Declarations }
    procedure SetItems(index: Integer; const val: TVKPipeNode);
    function GetItems(index: Integer): TVKPipeNode;

  public
    { Public Declarations }
    constructor Create(AOwner: TComponent);
    function Add: TVKPipeNode;
    function FindItemID(ID: Integer): TVKPipeNode;
    property Items[index: Integer]: TVKPipeNode read GetItems write SetItems;
      default;
  end;

  // TPipeParts
  //
  TPipePart = (ppOutside, ppInside, ppStartDisk, ppStopDisk);
  TPipeParts = set of TPipePart;

  // TPipeNodesColorMode
  //
  TPipeNodesColorMode = (pncmNone, pncmEmission, pncmAmbient, pncmDiffuse,
    pncmAmbientAndDiffuse);

  // TPipeTexCoordMode
  //
  TPipeTexCoordMode = (ptcmDefault, ptcmManual);

  // TPipeNormalMode
  //
  TPipeNormalMode = (pnmDefault, pnmAdvanced);

  // TVKPipe
  //
  { A solid object generated by extruding a circle along a trajectory. 
     Texture coordinates NOT supported yet. }
  TVKPipe = class(TVKPolygonBase)
  private
    { Private Declarations }
    FSlices: Integer;
    FParts: TPipeParts;
    FTriangleCount: Integer;
    FRadius: Single;
    FNodesColorMode: TPipeNodesColorMode;
    FTextCoordMode: TPipeTexCoordMode;
    FTextCoordTileS: Single;
    FTextCoordTileT: Single;
    FNormalMode: TPipeNormalMode;
    FNormalSmoothAngle: Single;

  protected
    { Protected Declarations }
    procedure CreateNodes; override;
    procedure SetSlices(const val: Integer);
    procedure SetParts(const val: TPipeParts);
    procedure SetRadius(const val: Single);
    function StoreRadius: Boolean;
    procedure SetNodesColorMode(const val: TPipeNodesColorMode);
    procedure SetTextCoordMode(const val: TPipeTexCoordMode);
    procedure SetTextCoordTileS(const val: Single);
    procedure SetTextCoordTileT(const val: Single);
    function StoreTextCoordTileS: Boolean;
    function StoreTextCoordTileT: Boolean;

    procedure SetNormalMode(const val: TPipeNormalMode);
    procedure SetNormalSmoothAngle(const val: Single);
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BuildList(var rci: TVKRenderContextInfo); override;

    { Number of triangles used for rendering. }
    property TriangleCount: Integer read FTriangleCount;

  published
    { Published Declarations }
    property Parts: TPipeParts read FParts write SetParts default [ppOutside];
    property Slices: Integer read FSlices write SetSlices default 16;
    property Radius: Single read FRadius write SetRadius;
    property NodesColorMode: TPipeNodesColorMode read FNodesColorMode write
      SetNodesColorMode default pncmNone;
    property TexCoordMode: TPipeTexCoordMode read FTextCoordMode
      write SetTextCoordMode default ptcmDefault;
    property TexCoordTileS: Single read FTextCoordTileS write SetTextCoordTileS
      stored StoreTextCoordTileS;
    property TexCoordTileT: Single read FTextCoordTileT write SetTextCoordTileT
      stored StoreTextCoordTileT;

    property NormalMode: TPipeNormalMode read FNormalMode write SetNormalMode
      default pnmDefault;
    property NormalSmoothAngle: Single read FNormalSmoothAngle write
      SetNormalSmoothAngle;

  end;

  // ------------------------------------------------------------------
  // ------------------------------------------------------------------
  // ------------------------------------------------------------------
implementation
// ------------------------------------------------------------------
// ------------------------------------------------------------------
// ------------------------------------------------------------------

uses
  System.SysUtils,
  VKS.Spline,
  VKS.VectorLists,
  VKS.XOpenGL;

// ------------------
// ------------------ TVKRevolutionSolid ------------------
// ------------------

// Create
//

constructor TVKRevolutionSolid.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FStartAngle := 0;
  FStopAngle := 360;
  FSlices := 16;
  FNormals := nsFlat;
  FNormalDirection := ndOutside;
  FParts := [rspOutside];
end;

// Destroy
//

destructor TVKRevolutionSolid.Destroy;
begin
  inherited Destroy;
end;

// SetStartAngle
//

procedure TVKRevolutionSolid.SetStartAngle(const val: Single);
begin
  if FStartAngle <> val then
  begin
    FStartAngle := val;
    if FStartAngle > FStopAngle then
      FStopAngle := FStartAngle;
    StructureChanged;
  end;
end;

// SetStopAngle
//

procedure TVKRevolutionSolid.SetStopAngle(const val: Single);
begin
  if FStopAngle <> val then
  begin
    FStopAngle := val;
    if FStopAngle < FStartAngle then
      FStartAngle := FStopAngle;
    StructureChanged;
  end;
end;

// StoreStopAngle
//

function TVKRevolutionSolid.StoreStopAngle: Boolean;
begin
  Result := (FStopAngle <> 360);
end;

// SetSlices
//

procedure TVKRevolutionSolid.SetSlices(const val: Integer);
begin
  if (val <> FSlices) and (val > 0) then
  begin
    FSlices := val;
    StructureChanged;
  end;
end;

// SetNormals
//

procedure TVKRevolutionSolid.SetNormals(const val: TNormalSmoothing);
begin
  if FNormals <> val then
  begin
    FNormals := val;
    StructureChanged;
  end;
end;

// SetYOffsetPerTurn
//

procedure TVKRevolutionSolid.SetYOffsetPerTurn(const val: Single);
begin
  if FYOffsetPerTurn <> val then
  begin
    FYOffsetPerTurn := val;
    StructureChanged;
  end;
end;

// SetNormalDirection
//

procedure TVKRevolutionSolid.SetNormalDirection(const val: TNormalDirection);
begin
  if FNormalDirection <> val then
  begin
    FNormalDirection := val;
    StructureChanged;
  end;
end;

// SetParts
//

procedure TVKRevolutionSolid.SetParts(const val: TRevolutionSolidParts);
begin
  if FParts <> val then
  begin
    FParts := val;
    StructureChanged;
  end;
end;

// Assign
//

procedure TVKRevolutionSolid.Assign(Source: TPersistent);
begin
  if Source is TVKRevolutionSolid then
  begin
    FStartAngle := TVKRevolutionSolid(Source).FStartAngle;
    FStopAngle := TVKRevolutionSolid(Source).FStopAngle;
    FSlices := TVKRevolutionSolid(Source).FSlices;
    FNormals := TVKRevolutionSolid(Source).FNormals;
    FYOffsetPerTurn := TVKRevolutionSolid(Source).FYOffsetPerTurn;
    FNormalDirection := TVKRevolutionSolid(Source).FNormalDirection;
    FParts := TVKRevolutionSolid(Source).FParts;
  end;
  inherited Assign(Source);
end;

// BuildList
//

procedure TVKRevolutionSolid.BuildList(var rci: TVKRenderContextInfo);
var
  deltaAlpha, startAlpha, stopAlpha, alpha: Single;
  deltaS: Single;
  deltaYOffset, yOffset, startYOffset: Single;
  lastNormals: PAffineVectorArray;
  firstStep, gotYDeltaOffset: Boolean;

  procedure CalcNormal(const ptTop, ptBottom: PAffineVector; var normal:
    TAffineVector);
  var
    tb: TAffineVector;
    mx, mz: Single;
  begin
    mx := ptBottom^.X + ptTop^.X;
    mz := ptBottom^.Z + ptTop^.Z;
    VectorSubtract(ptBottom^, ptTop^, tb);
    normal.X := -tb.Y * mx;
    normal.Y := mx * tb.X + mz * tb.Z;
    normal.Z := -mz * tb.Y;
    NormalizeVector(normal);
  end;

  procedure BuildStep(ptTop, ptBottom: PAffineVector; invertNormals: Boolean;
    topT, bottomT: Single);
  var
    i: Integer;
    topBase, topNext, bottomBase, bottomNext, normal, topNormal, bottomNormal:
      TAffineVector;
    topTPBase, topTPNext, bottomTPBase, bottomTPNext: TTexPoint;
    nextAlpha: Single;
    ptBuffer: PAffineVector;

    procedure SetLocalNormals;
    begin
      if (FNormals = nsFlat) or FirstStep then
      begin
        topNormal := normal;
        bottomNormal := normal;
        if (FNormals = nsSmooth) then
          lastNormals^[i] := normal;
      end
      else if (FNormals = nsSmooth) then
      begin
        if invertNormals then
        begin
          topNormal := normal;
          bottomNormal := lastNormals^[i];
        end
        else
        begin
          topNormal := lastNormals^[i];
          bottomNormal := normal;
        end;
        lastNormals^[i] := normal;
      end;
    end;

  begin
    // to invert normals, we just need to flip top & bottom
    if invertNormals then
    begin
      ptBuffer := ptTop;
      ptTop := ptBottom;
      ptBottom := ptBuffer;
    end;
    // generate triangle strip for a level
    // TODO : support for triangle fans (when ptTop or ptBottom is on the Y Axis)
    alpha := startAlpha;
    i := 0;
    yOffset := startYOffset;
    topTPBase.S := 0;
    bottomTPBase.S := 0;
    topTPBase.T := topT;
    bottomTPBase.T := bottomT;
    VectorRotateAroundY(ptTop^, alpha, topBase);
    VectorRotateAroundY(ptBottom^, alpha, bottomBase);
    if gotYDeltaOffset then
    begin
      topBase.Y := topBase.Y + yOffset;
      bottomBase.Y := bottomBase.Y + yOffset;
      yOffset := yOffset + deltaYOffset;
    end;
    CalcNormal(@topBase, @bottomBase, normal);
    SetLocalNormals;
    inc(i);
    topTPNext := topTPBase;
    bottomTPNext := bottomTPBase;
    glBegin(GL_TRIANGLE_STRIP);
    glNormal3fv(@topNormal);
    glTexCoord2fv(@topTPBase);
    glVertex3fv(@topBase);
    while alpha < stopAlpha do
    begin
      glNormal3fv(@bottomNormal);
      glTexCoord2fv(@bottomTPBase);
      glVertex3fv(@bottomBase);
      nextAlpha := alpha + deltaAlpha;
      topTPNext.S := topTPNext.S + deltaS;
      bottomTPNext.S := bottomTPNext.S + deltaS;
      VectorRotateAroundY(ptTop^, nextAlpha, topNext);
      VectorRotateAroundY(ptBottom^, nextAlpha, bottomNext);
      if gotYDeltaOffset then
      begin
        topNext.Y := topNext.Y + yOffset;
        bottomNext.Y := bottomNext.Y + yOffset;
        yOffset := yOffset + deltaYOffset
      end;
      CalcNormal(@topNext, @bottomNext, normal);
      SetLocalNormals;
      inc(i);
      glTexCoord2fv(@topTPNext);
      glNormal3fv(@topNormal);
      glVertex3fv(@topNext);
      alpha := nextAlpha;
      topBase := topNext;
      topTPBase := topTPNext;
      bottomBase := bottomNext;
      bottomTPBase := bottomTPNext;
    end;
    glNormal3fv(@bottomNormal);
    glTexCoord2fv(@bottomTPBase);
    glVertex3fv(@bottomBase);
    glEnd;
    firstStep := False;
  end;

var
  i, nbSteps, nbDivisions: Integer;
  splinePos, lastSplinePos, bary, polygonNormal: TAffineVector;
  f: Single;
  spline: TCubicSpline;
  invertedNormals: Boolean;
  polygon: TVKNodes;
begin
  if (Nodes.Count > 1) and (FStopAngle > FStartAngle) then
  begin
    startAlpha := FStartAngle * cPIdiv180;
    stopAlpha := FStopAngle * cPIdiv180;
    nbSteps := Round(((stopAlpha - startAlpha) / (2 * PI)) * FSlices);
    // drop 0.1% to slice count to care for precision losses
    deltaAlpha := (stopAlpha - startAlpha) / (nbSteps * 0.999);
    deltaS := (stopAlpha - startAlpha) / (2 * PI * nbSteps);
    gotYDeltaOffset := FYOffsetPerTurn <> 0;
    if gotYDeltaOffset then
      deltaYOffset := (FYOffsetPerTurn * (stopAlpha - startAlpha) / (2 * PI)) /
        nbSteps
    else
      deltaYOffset := 0;
    startYOffset := YOffsetPerTurn * startAlpha / (2 * PI);
    invertedNormals := (FNormalDirection = ndInside);
    FTriangleCount := 0;
    // generate sides
    if (rspInside in FParts) or (rspOutside in FParts) then
    begin
      // allocate lastNormals buffer (if smoothing)
      if FNormals = nsSmooth then
      begin
        GetMem(lastNormals, (FSlices + 2) * SizeOf(TAffineVector));
        firstStep := True;
      end;
      // start working
      if rspInside in Parts then
      begin
        firstStep := True;
        if (Division < 2) or (SplineMode = lsmLines) then
        begin
          // standard line(s), draw directly
          for i := 0 to Nodes.Count - 2 do
            with Nodes[i] do
            begin
              BuildStep(PAffineVector(Nodes[i].AsAddress),
                PAffineVector(Nodes[i + 1].AsAddress), not invertedNormals,
                i / (Nodes.Count - 1), (i + 1) / (Nodes.Count - 1));
            end;
          FTriangleCount := nbSteps * Nodes.Count * 2;
        end
        else
        begin
          // cubic spline
          Spline := Nodes.CreateNewCubicSpline;
          Spline.SplineAffineVector(0, lastSplinePos);
          f := 1 / Division;
          nbDivisions := (Nodes.Count - 1) * Division;
          for i := 1 to nbDivisions do
          begin
            Spline.SplineAffineVector(i * f, splinePos);
            BuildStep(@lastSplinePos, @splinePos, not invertedNormals,
              (i - 1) / nbDivisions, i / nbDivisions);
            lastSplinePos := splinePos;
          end;
          Spline.Free;
          FTriangleCount := nbSteps * nbDivisions * 2;
        end;
      end;
      if rspOutside in Parts then
      begin
        firstStep := True;
        if (Division < 2) or (SplineMode = lsmLines) then
        begin
          // standard line(s), draw directly
          for i := 0 to Nodes.Count - 2 do
            with Nodes[i] do
            begin
              BuildStep(PAffineVector(Nodes[i].AsAddress),
                PAffineVector(Nodes[i + 1].AsAddress), invertedNormals,
                i / (Nodes.Count - 1), (i + 1) / (Nodes.Count - 1));
            end;
          FTriangleCount := nbSteps * Nodes.Count * 2;
        end
        else
        begin
          // cubic spline
          Spline := Nodes.CreateNewCubicSpline;
          Spline.SplineAffineVector(0, lastSplinePos);
          f := 1 / Division;
          nbDivisions := (Nodes.Count - 1) * Division;
          for i := 1 to nbDivisions do
          begin
            Spline.SplineAffineVector(i * f, splinePos);
            BuildStep(@lastSplinePos, @splinePos, invertedNormals,
              (i - 1) / nbDivisions, i / nbDivisions);
            lastSplinePos := splinePos;
          end;
          Spline.Free;
          FTriangleCount := nbSteps * nbDivisions * 2;
        end;
      end;
      if (rspInside in FParts) and (rspOutside in FParts) then
        FTriangleCount := FTriangleCount * 2;
      glTexCoord2fv(@NullTexPoint);
      // release lastNormals buffer (if smoothing)
      if FNormals = nsSmooth then
        FreeMem(lastNormals);
    end;
    // tessellate start/stop polygons
    if (rspStartPolygon in FParts) or (rspStopPolygon in FParts) then
    begin
      bary := Nodes.Barycenter;
      bary.Y := 0;
      NormalizeVector(bary);
      // tessellate start polygon
      if rspStartPolygon in FParts then
      begin
        polygon := Nodes.CreateCopy(nil);
        with polygon do
        begin
          RotateAroundY(RadianToDeg(startAlpha));
          Translate(AffineVectorMake(0, startYOffset, 0));
          if invertedNormals then
            alpha := startAlpha + PI / 2
          else
            alpha := startAlpha + PI + PI / 2;
          polygonNormal := VectorRotateAroundY(bary, alpha);
          if SplineMode = lsmLines then
            RenderTesselatedPolygon(False, @polygonNormal, 1)
          else
            RenderTesselatedPolygon(False, @polygonNormal, Division);
          Free;
        end;
        // estimated count
        FTriangleCount := FTriangleCount + Nodes.Count + (Nodes.Count shr 1);
      end;
      // tessellate stop polygon
      if rspStopPolygon in FParts then
      begin
        polygon := Nodes.CreateCopy(nil);
        with polygon do
        begin
          RotateAroundY(RadianToDeg(stopAlpha));
          Translate(AffineVectorMake(0, startYOffset + (stopAlpha - startAlpha)
            * YOffsetPerTurn / (2 * PI), 0));
          if invertedNormals then
            alpha := stopAlpha + PI + PI / 2
          else
            alpha := stopAlpha + PI / 2;
          polygonNormal := VectorRotateAroundY(bary, alpha);
          if SplineMode = lsmLines then
            RenderTesselatedPolygon(False, @polygonNormal, 1)
          else
            RenderTesselatedPolygon(False, @polygonNormal, Division);
          Free;
        end;
        // estimated count
        FTriangleCount := FTriangleCount + Nodes.Count + (Nodes.Count shr 1);
      end;
    end;
  end;
end;

// AxisAlignedDimensionsUnscaled
//

function TVKRevolutionSolid.AxisAlignedDimensionsUnscaled: TVector;
var
  maxRadius: Single;
  maxHeight: Single;
  i: integer;
begin
  maxRadius := 0;
  maxHeight := 0;
  if FAxisAlignedDimensionsCache.X < 0 then
  begin
    for i := 0 to Nodes.Count - 1 do
    begin
      maxHeight := MaxFloat(maxHeight, Abs(Nodes[i].Y));
      maxRadius := MaxFloat(maxRadius, Sqr(Nodes[i].X) + Sqr(Nodes[i].Z));
    end;
    maxRadius := sqrt(maxRadius);
    FAxisAlignedDimensionsCache.X := maxRadius;
    FAxisAlignedDimensionsCache.Y := maxHeight;
    FAxisAlignedDimensionsCache.Z := maxRadius;
  end;
  SetVector(Result, FAxisAlignedDimensionsCache);
end;

// StructureChanged
//

procedure TVKRevolutionSolid.StructureChanged;
begin
  FAxisAlignedDimensionsCache.X := -1;
  inherited;
end;

// ------------------
// ------------------ TVKPipeNode ------------------
// ------------------

// Create
//

constructor TVKPipeNode.Create(Collection: TCollection);
begin
  inherited Create(Collection);
  FRadiusFactor := 1.0;
  FColor := TVKColor.CreateInitialized(Self, clrBlack, ColorChanged);
  FTexCoordT := 1.0;
end;

// Destroy
//

destructor TVKPipeNode.Destroy;
begin
  FColor.Free;
  inherited Destroy;
end;

// Assign
//

procedure TVKPipeNode.Assign(Source: TPersistent);
begin
  if Source is TVKPipeNode then
  begin
    RadiusFactor := TVKPipeNode(Source).FRadiusFactor;
    Color.DirectColor := TVKPipeNode(Source).Color.DirectColor;
    TexCoordT := TVKPipeNode(Source).FTexCoordT;
  end;
  inherited;
end;

// GetDisplayName
//

function TVKPipeNode.GetDisplayName: string;
begin
  Result := Format('%s / rf = %.3f', [inherited GetDisplayName, RadiusFactor]);
  ;
end;

// SetRadiusFactor
//

procedure TVKPipeNode.SetRadiusFactor(const val: Single);
begin
  if FRadiusFactor <> val then
  begin
    FRadiusFactor := val;
    Changed(false);
    //(Collection as TVKNodes).NotifyChange;
  end;
end;

// StoreRadiusFactor
//

function TVKPipeNode.StoreRadiusFactor: Boolean;
begin
  Result := (FRadiusFactor <> 1.0);
end;

function TVKPipeNode.StoreTexCoordT: Boolean;
begin
  Result := (FTexCoordT <> 1.0);
end;

// SetColor
//

procedure TVKPipeNode.SetColor(const val: TVKColor);
begin
  FColor.Assign(val);
end;

// ColorChanged
//

procedure TVKPipeNode.ColorChanged(sender: TObject);
begin
  TVKPipeNodes(Collection).NotifyChange;
end;

// ------------------
// ------------------ TVKPipeNodes ------------------
// ------------------

constructor TVKPipeNodes.Create(AOwner: TComponent);
begin
  inherited Create(AOwner, TVKPipeNode);
end;

procedure TVKPipeNodes.SetItems(index: Integer; const val: TVKPipeNode);
begin
  inherited Items[index] := val;
end;

function TVKPipeNodes.GetItems(index: Integer): TVKPipeNode;
begin
  Result := TVKPipeNode(inherited Items[index]);
end;

function TVKPipeNodes.Add: TVKPipeNode;
begin
  Result := (inherited Add) as TVKPipeNode;
end;

function TVKPipeNodes.FindItemID(ID: Integer): TVKPipeNode;
begin
  Result := (inherited FindItemID(ID)) as TVKPipeNode;
end;

// ------------------
// ------------------ TVKPipe ------------------
// ------------------

// Create
//

constructor TVKPipe.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FSlices := 16;
  FParts := [ppOutside];
  FRadius := 1.0;
  FTriangleCount := 0;
  FTextCoordMode := ptcmDefault;
  FTextCoordTileS := 1;
  FTextCoordTileT := 1;
  FNormalMode := pnmDefault;
  FNormalSmoothAngle := 0;
end;

// CreateNodes
//

procedure TVKPipe.CreateNodes;
begin
  FNodes := TVKPipeNodes.Create(Self);
end;

// Destroy
//

destructor TVKPipe.Destroy;
begin
  inherited Destroy;
end;

// SetSlices
//

procedure TVKPipe.SetSlices(const val: Integer);
begin
  if (val <> FSlices) and (val > 0) then
  begin
    FSlices := val;
    StructureChanged;
  end;
end;

// SetParts
//

procedure TVKPipe.SetParts(const val: TPipeParts);
begin
  if FParts <> val then
  begin
    FParts := val;
    StructureChanged;
  end;
end;

// SetRadius
//

procedure TVKPipe.SetRadius(const val: Single);
begin
  if FRadius <> val then
  begin
    FRadius := val;
    StructureChanged;
  end;
end;

// StoreRadius
//

function TVKPipe.StoreRadius: Boolean;
begin
  Result := (FRadius <> 1.0);
end;

function TVKPipe.StoreTextCoordTileS: Boolean;
begin
  Result := (FTextCoordTileS <> 1.0);
end;

function TVKPipe.StoreTextCoordTileT: Boolean;
begin
  Result := (FTextCoordTileT <> 1.0);
end;

// SetNodesColorMode
//

procedure TVKPipe.SetNodesColorMode(const val: TPipeNodesColorMode);
begin
  if val <> FNodesColorMode then
  begin
    FNodesColorMode := val;
    StructureChanged;
  end;
end;

// SetTextCoordMode
//

procedure TVKPipe.SetTextCoordMode(const val: TPipeTexCoordMode);
begin
  if val <> FTextCoordMode then
  begin
    FTextCoordMode := val;
    StructureChanged;
  end;
end;

// TextCoordTileS
//

procedure TVKPipe.SetTextCoordTileS(const val: Single);
begin
  if val <> FTextCoordTileS then
  begin
    FTextCoordTileS := val;
    StructureChanged;
  end;
end;

// TextCoordTileT
//

procedure TVKPipe.SetTextCoordTileT(const val: Single);
begin
  if val <> FTextCoordTileT then
  begin
    FTextCoordTileT := val;
    StructureChanged;
  end;
end;

// SetNormalMode
//

procedure TVKPipe.SetNormalMode(const val: TPipeNormalMode);
begin
  if val <> FNormalMode then
  begin
    FNormalMode := val;
    StructureChanged;
  end;
end;

// SetNormalSmoothAngle
//

procedure TVKPipe.SetNormalSmoothAngle(const val: Single);
begin
  if val <> FNormalSmoothAngle then
  begin
    FNormalSmoothAngle := val;
    if NormalMode = pnmAdvanced then
      StructureChanged;
  end;
end;

// Assign
//

procedure TVKPipe.Assign(Source: TPersistent);
begin
  if Source is TVKPipe then
  begin
    Slices := TVKPipe(Source).Slices;
    Parts := TVKPipe(Source).Parts;
    Radius := TVKPipe(Source).Radius;
    NodesColorMode := TVKPipe(Source).NodesColorMode;
    TexCoordMode := TVKPipe(Source).TexCoordMode;
    TexCoordTileS := TVKPipe(Source).TexCoordTileS;
    TexCoordTileT := TVKPipe(Source).TexCoordTileT;
  end;
  inherited;
end;

// BuildList
//
var
  vSinCache, vCosCache: array of Single;

procedure TVKPipe.BuildList(var rci: TVKRenderContextInfo);
type
  TNodeData = record
    pos: TAffineVector;
    normal: TAffineVector;
    innormal: TAffineVector;
    sidedir: TVector3f;
  end;
  TRowData = record
    node: array of TNodeData;
    color: TColorVector;
    center: TVector3f;
    textcoordT: Single;
  end;
  PRowData = ^TRowData;
const
  cPNCMtoEnum: array[pncmEmission..pncmAmbientAndDiffuse] of GLEnum =
    (GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_AMBIENT_AND_DIFFUSE);

  procedure CalculateRow(row: PRowData;
    const center, normal: TAffineVector; radius: Single);
  var
    i: Integer;
    vx, vy: TAffineVector;
  begin
    // attempt to use object's Z as Y vector
    VectorCrossProduct(ZVector, normal, vx);
    if VectorNorm(vx) < 1e-7 then
    begin
      // bad luck, the X vector will do (unless it's or normal that was null)
      if VectorNorm(normal) < 1e-7 then
      begin
        SetVector(vx, XVector);
        SetVector(vy, ZVector);
      end
      else
      begin
        VectorCrossProduct(XVector, normal, vx);
        NormalizeVector(vx);
        VectorCrossProduct(normal, vx, vy);
      end;
    end
    else
    begin
      NormalizeVector(vx);
      VectorCrossProduct(normal, vx, vy);
    end;
    NormalizeVector(vy);
    ScaleVector(vx, FRadius);
    ScaleVector(vy, FRadius);
    // generate the circle
    for i := 0 to High(row^.node) do
    begin
      row^.node[i].normal := VectorCombine(vx, vy, vCosCache[i], vSinCache[i]);
      row^.node[i].pos := VectorCombine(PAffineVector(@center)^,
        row^.node[i].normal, 1, radius);
      SetVector(row^.node[i].sidedir, 0, 0, 0);
    end;
    row^.center := center;
  end;

  procedure RenderDisk(row: PRowData;
    const center: TVector; const normal: TAffineVector;
    invert: Boolean; TextCoordTileS: Single);
  var
    i: Integer;
  begin
    begin
      if NodesColorMode <> pncmNone then
        glColor4fv(@row^.color);
      // it was necessary to change build process to generate textcoords
      glBegin(GL_TRIANGLE_STRIP);
      glNormal3fv(@normal);

      case TexCoordMode of
        ptcmDefault, ptcmManual:
          begin
            if invert then
            begin
              for i := 0 to High(row^.node) - 1 do
              begin
                glTexCoord2f(i / (High(row^.node)) * TextCoordTileS, 1);
                glVertex3fv(@row^.node[i].pos);
                glTexCoord2f(i / (High(row^.node)) * TextCoordTileS, 0);
                glVertex3fv(@center);
              end;
              glTexCoord2f(TextCoordTileS, 1);
              glVertex3fv(@row^.node[High(row^.node)].pos);
            end
            else
            begin
              for i := High(row^.node) downto 1 do
              begin
                glTexCoord2f(i / (High(row^.node)) * TextCoordTileS, 0);
                glVertex3fv(@row^.node[i].pos);
                glTexCoord2f(i / (High(row^.node)) * TextCoordTileS, 1);
                glVertex3fv(@center);
              end;
              glTexCoord2f(0, 0);
              glVertex3fv(@row^.node[0].pos);
            end;
          end;
      end;

      glEnd;
    end;
  end;

  procedure CalculateSides(prevRow, curRow: PRowData; trajvec: TVector3f);
  var
    j, k, m, n: Integer;
    deltaNormal, deltaPos: array of Double;
    smoothanglerad: Single;
  begin
    SetLength(deltanormal, Slices);
    SetLength(deltapos, Slices);
    for k := 0 to Slices - 1 do
    begin //rotate index for curRow
      deltanormal[k] := 0; //sum of difference for normal vector
      deltapos[k] := 0; //sum of difference for pos vector
      for j := 0 to Slices - 1 do
      begin //over all places
        n := (j + k) mod Slices;
        deltanormal[k] := deltanormal[k] + VectorSpacing(curRow^.node[n].normal,
          prevRow^.node[j].normal);
        deltapos[k] := deltapos[k] + VectorSpacing(curRow^.node[n].pos,
          prevRow^.node[j].pos);
      end;
    end;
    //Search minimum
    // only search in deltapos, if i would search in deltanormal,
    // the same index of minimum would be found
    m := 0;
    for k := 1 to Slices - 1 do
      if deltapos[m] > deltapos[k] then
        m := k;
    // rotate count
    for k := 1 to m do
    begin
      // rotate the values of curRow
      curRow^.node[Slices] := curRow^.node[0];
      System.Move(curRow^.node[1], curRow^.node[0], SizeOf(TNodeData) * Slices);
      curRow^.node[Slices] := curRow^.node[0];
    end;

    case NormalMode of
      pnmDefault:
        begin
          for j := 0 to Slices do
          begin
            curRow.node[j].innormal := VectorNegate(curRow.node[j].normal);
            prevRow.node[j].innormal := VectorNegate(prevRow.node[j].normal);
          end;
        end;
      pnmAdvanced:
        begin
          smoothanglerad := DegToRadian(NormalSmoothAngle);
          for j := 0 to Slices do
          begin
            curRow.node[j].sidedir :=
              VectorNormalize(VectorSubtract(curRow.node[j].pos,
              prevRow.node[j].pos));
            if VectorDotProduct(curRow.node[j].sidedir, prevRow.node[j].sidedir)
              < Cos(smoothanglerad) then
            begin
              if VectorDotProduct(curRow.node[j].sidedir, VectorNormalize(
                VectorSubtract(curRow.node[j].pos, curRow.center))) > 0.99 then
              begin
                curRow.node[j].normal :=
                  VectorCrossProduct(curRow.node[j].sidedir,
                  VectorCrossProduct(curRow.node[j].sidedir,
                    VectorNormalize(trajvec)));
                prevRow.node[j].normal :=
                  VectorCrossProduct(curRow.node[j].sidedir,
                  VectorCrossProduct(curRow.node[j].sidedir,
                    VectorNormalize(trajvec)));
              end
              else
              begin
                if VectorDotProduct(curRow.node[j].sidedir, VectorNormalize(
                  VectorSubtract(curRow.node[j].pos, curRow.center))) < -0.99
                    then
                begin
                  curRow.node[j].normal := VectorCrossProduct(VectorCrossProduct
                    (curRow.node[j].sidedir, VectorNormalize(trajvec)),
                      curRow.node[j].sidedir);
                  prevRow.node[j].normal := VectorCrossProduct(VectorCrossProduct
                    (curRow.node[j].sidedir, VectorNormalize(trajvec)),
                      curRow.node[j].sidedir);
                end
                else
                begin
                  if VectorDotProduct(trajvec, curRow.node[j].sidedir) < 0 then
                  begin
                    curRow.node[j].normal :=
                      VectorCrossProduct(VectorNormalize(VectorCrossProduct
                      (VectorNormalize(VectorSubtract(curRow.node[j].pos,
                        curRow.center)),
                      curRow.node[j].sidedir)), curRow.node[j].sidedir);
                    prevRow.node[j].normal :=
                      VectorCrossProduct(VectorNormalize(VectorCrossProduct
                      (VectorNormalize(VectorSubtract(prevRow.node[j].pos,
                        prevRow.center)),
                      curRow.node[j].sidedir)), curRow.node[j].sidedir);
                  end
                  else
                  begin
                    curRow.node[j].normal :=
                      VectorCrossProduct(curRow.node[j].sidedir, VectorNormalize
                      (VectorCrossProduct(VectorNormalize(VectorSubtract(curRow.node[j].pos, curRow.center)),
                      curRow.node[j].sidedir)));
                    prevRow.node[j].normal :=
                      VectorCrossProduct(curRow.node[j].sidedir, VectorNormalize
                      (VectorCrossProduct(VectorNormalize(VectorSubtract(prevRow.node[j].pos, prevRow.center)),
                      curRow.node[j].sidedir)));
                  end;
                end;
                if VectorLength(curRow.node[j].normal) = 0 then
                  curRow.node[j].normal := prevRow.node[j].normal;
                if VectorLength(prevRow.node[j].normal) = 0 then
                  prevRow.node[j].normal := curRow.node[j].normal;
                //compute inside normales
                curRow.node[j].innormal := VectorNegate(curRow.node[j].normal);
                prevRow.node[j].innormal :=
                  VectorNegate(prevRow.node[j].normal);
              end;
            end
            else
            begin
              if VectorDotProduct(curRow.node[j].sidedir,
                VectorNormalize(VectorSubtract
                (curRow.node[j].pos, curRow.center))) > 0.99 then
              begin
                curRow.node[j].normal :=
                  VectorCrossProduct(curRow.node[j].sidedir,
                  VectorCrossProduct(curRow.node[j].sidedir,
                    VectorNormalize(trajvec)));
              end
              else
              begin
                if VectorDotProduct(curRow.node[j].sidedir, VectorNormalize(
                  VectorSubtract(curRow.node[j].pos, curRow.center))) < -0.99
                    then
                begin
                  curRow.node[j].normal := VectorCrossProduct(VectorCrossProduct
                    (curRow.node[j].sidedir, VectorNormalize(trajvec)),
                      curRow.node[j].sidedir);
                end
                else
                begin
                  if VectorDotProduct(trajvec, curRow.node[j].sidedir) < 0 then
                  begin
                    curRow.node[j].normal :=
                      VectorCrossProduct(VectorNormalize(VectorCrossProduct
                      (VectorNormalize(VectorSubtract(curRow.node[j].pos,
                        curRow.center)),
                      curRow.node[j].sidedir)), curRow.node[j].sidedir);
                  end
                  else
                  begin
                    curRow.node[j].normal :=
                      VectorCrossProduct(curRow.node[j].sidedir, VectorNormalize
                      (VectorCrossProduct(VectorNormalize(VectorSubtract(curRow.node[j].pos,
                      curRow.center)), curRow.node[j].sidedir)));
                  end;
                end;
                //compute inside normales
                curRow.node[j].innormal := VectorNegate(curRow.node[j].normal);
              end;
            end;
          end;
        end;
    end;
  end;

  procedure RenderSides(prevRow, curRow: PRowData; TextCoordTileS,
    TextCoordTileT: Single; outside: Boolean);
  var
    j: Integer;
  begin
    begin
      glBegin(GL_TRIANGLE_STRIP);
      if outside then
      begin
        if NodesColorMode <> pncmNone then
          glColor4fv(@curRow^.color);

        glTexCoord2f(0, curRow^.textcoordT * TextCoordTileT);
        glNormal3fv(@curRow^.node[0].normal);
        glVertex3fv(@curRow^.node[0].pos);
        for j := 0 to Slices - 1 do
        begin
          if NodesColorMode <> pncmNone then
            glColor4fv(@prevRow^.color);
          glTexCoord2f(j / Slices * TextCoordTileS, prevRow^.textcoordT *
            TextCoordTileT);
          glNormal3fv(@prevRow^.node[j].normal);
          glVertex3fv(@prevRow^.node[j].pos);
          if NodesColorMode <> pncmNone then
            glColor4fv(@curRow^.color);
          glTexCoord2f((j + 1) / Slices * TextCoordTileS, curRow^.textcoordT *
            TextCoordTileT);
          glNormal3fv(@curRow^.node[j + 1].normal);
          glVertex3fv(@curRow^.node[j + 1].pos);
        end;
        if NodesColorMode <> pncmNone then
          glColor4fv(@prevRow^.color);
        glTexCoord2f(TextCoordTileS, prevRow^.textcoordT * TextCoordTileT);
        glNormal3fv(@prevRow^.node[Slices].normal);
        glVertex3fv(@prevRow^.node[Slices].pos);
      end
      else
      begin
        for j := 0 to Slices do
        begin
          curRow.node[j].innormal := VectorNegate(curRow.node[j].normal);
          prevRow.node[j].innormal := VectorNegate(prevRow.node[j].normal);
        end;
        if NodesColorMode <> pncmNone then
          glColor4fv(@prevRow^.color);

        glTexCoord2f(0, prevRow^.textcoordT * TextCoordTileT);
        glNormal3fv(@prevRow^.node[0].innormal);
        glVertex3fv(@prevRow^.node[0].pos);
        for j := 0 to Slices - 1 do
        begin
          if NodesColorMode <> pncmNone then
            glColor4fv(@curRow^.color);
          glTexCoord2f(j / Slices * TextCoordTileS, curRow^.textcoordT *
            TextCoordTileT);
          glNormal3fv(@curRow^.node[j].innormal);
          glVertex3fv(@curRow^.node[j].pos);
          if NodesColorMode <> pncmNone then
            glColor4fv(@prevRow^.color);
          glTexCoord2f((j + 1) / Slices * TextCoordTileS, prevRow^.textcoordT *
            TextCoordTileT);
          glNormal3fv(@prevRow^.node[j + 1].innormal);
          glVertex3fv(@prevRow^.node[j + 1].pos);
        end;
        if NodesColorMode <> pncmNone then
          glColor4fv(@curRow^.color);
        glTexCoord2f(TextCoordTileS, curRow^.textcoordT * TextCoordTileT);
        glNormal3fv(@curRow^.node[Slices].innormal);
        glVertex3fv(@curRow^.node[Slices].pos);
      end;
      glEnd;
    end;
  end;
var
  i, curRow, nbDivisions, k: Integer;
  normal, splinePos: TAffineVector;
  rows: array[0..1] of TRowData;
  ra: PFloatArray;
  posSpline, rSpline: TCubicSpline;
  f, t: Single;
begin
  FTriangleCount := 0;
  if Nodes.Count = 0 then
    Exit;
  SetLength(rows[0].node, Slices + 1);
  SetLength(rows[1].node, Slices + 1);
  if (Length(vSinCache) <> Slices + 1) or (Length(vCosCache) <> Slices + 1) then
  begin
    SetLength(vSinCache, Slices + 1);
    SetLength(vCosCache, Slices + 1);
    PrepareSinCosCache(vSinCache, vCosCache, 0, 360);
  end;
  if (SplineMode = lsmCubicSpline) and (Nodes.Count > 1) then
  begin
    // create position spline
    posSpline := Nodes.CreateNewCubicSpline;
    // create radius spline
    GetMem(ra, SizeOf(GLfloat) * Nodes.Count);
    for i := 0 to Nodes.Count - 1 do
      ra^[i] := TVKPipeNode(Nodes[i]).RadiusFactor;
    rSpline := TCubicSpline.Create(ra, nil, nil, nil, Nodes.Count);
    FreeMem(ra);
    normal := posSpline.SplineSlopeVector(0);
  end
  else
  begin
    normal := Nodes.Vector(0);
    posSpline := nil;
    rSpline := nil;
  end;

  if NodesColorMode <> pncmNone then
  begin
    glColorMaterial(GL_FRONT_AND_BACK, cPNCMtoEnum[NodesColorMode]);
    rci.VKStates.Enable(stColorMaterial);
  end
  else
    rci.VKStates.Disable(stColorMaterial);

  CalculateRow(@rows[0], PAffineVector(@Nodes[0].AsVector)^, normal,
    TVKPipeNode(Nodes[0]).RadiusFactor);
  rows[0].color := TVKPipeNodes(Nodes)[0].Color.Color;
  case TexCoordMode of
    ptcmDefault: rows[0].textcoordT := 0;
    ptcmManual: rows[0].textcoordT := TVKPipeNode(Nodes[0]).TexCoordT;
  end;

  if ppStartDisk in Parts then
  begin
    NegateVector(normal);
    if ppOutside in Parts then
    begin
      RenderDisk(@rows[0], Nodes[0].AsVector, normal, True, TexCoordTileS);
      FTriangleCount := FTriangleCount + Slices * 2; //Slices+1;
    end;
    if ppInside in Parts then
    begin
      RenderDisk(@rows[0], Nodes[0].AsVector, VectorNegate(normal), False,
        TexCoordTileS);
      FTriangleCount := FTriangleCount + Slices * 2; //Slices+1;
    end;
  end;
  if (Nodes.Count > 1) then
  begin
    if SplineMode = lsmCubicSpline then
    begin
      f := 1 / Division;
      nbDivisions := (Nodes.Count - 1) * Division;
      for i := 1 to nbDivisions do
      begin
        t := i * f;
        posSpline.SplineAffineVector(t, splinePos);
        normal := posSpline.SplineSlopeVector(t);
        NormalizeVector(normal);
        curRow := (i and 1);
        CalculateRow(@rows[curRow], splinePos, normal,
          rSpline.SplineX(t));
        if NodesColorMode <> pncmNone then
        begin
          k := Trunc(t);
          if k < Nodes.Count - 1 then
            rows[curRow].color := VectorLerp(TVKPipeNodes(Nodes)[k].Color.Color,
              TVKPipeNodes(Nodes)[k + 1].Color.Color,
              Frac(t))
          else
            rows[curRow].color := TVKPipeNodes(Nodes)[k].Color.Color;
        end;
        //
        case TexCoordMode of
          ptcmDefault:
            begin
              k := Trunc(t);
              if k < Nodes.Count - 1 then
                rows[curRow].textcoordT := Lerp(k,
                  k + 1,
                  Frac(t))
              else
                rows[curRow].textcoordT := k;
            end;
          ptcmManual:
            begin
              k := Trunc(t);
              if k < Nodes.Count - 1 then
                rows[curRow].textcoordT := Lerp(TVKPipeNode(Nodes[k]).TexCoordT,
                  TVKPipeNode(Nodes[k + 1]).TexCoordT,
                  Frac(t))
              else
                rows[curRow].textcoordT := TVKPipeNode(Nodes[k]).TexCoordT;
            end;
        end;
        if (ppOutside in Parts) or (ppInside in Parts) then
          CalculateSides(@rows[curRow xor 1], @rows[curRow], normal);
        if ppOutside in Parts then
          RenderSides(@rows[curRow xor 1], @rows[curRow], TexCoordTileS,
            TexCoordTileT, True);
        if ppInside in Parts then
          RenderSides(@rows[curRow xor 1], @rows[curRow], TexCoordTileS,
            TexCoordTileT, False);
      end;
      i := nbDivisions * (Slices + 1) * 2;
      if ppOutside in Parts then
        Inc(FTriangleCount, i);
      if ppInside in Parts then
        Inc(FTriangleCount, i);
    end
    else
    begin
      for i := 1 to Nodes.Count - 1 do
      begin
        curRow := (i and 1);
        //Initialize Texture coordinates
        case TexCoordMode of
          ptcmDefault: rows[curRow].textcoordT := i;
          ptcmManual: rows[curRow].textcoordT :=
            TVKPipeNode(Nodes[i]).TexCoordT;
        end;
        CalculateRow(@rows[curRow], PAffineVector(@Nodes[i].AsVector)^,
          Nodes.Vector(i), TVKPipeNode(Nodes[i]).RadiusFactor);
        rows[curRow].color := TVKPipeNodes(Nodes)[i].Color.Color;
        if (ppOutside in Parts) or (ppInside in Parts) then
          CalculateSides(@rows[curRow xor 1], @rows[curRow], Nodes.Vector(i));
        if ppOutside in Parts then
          RenderSides(@rows[curRow xor 1], @rows[curRow], TexCoordTileS,
            TexCoordTileT, True);
        if ppInside in Parts then
          RenderSides(@rows[curRow xor 1], @rows[curRow], TexCoordTileS,
            TexCoordTileT, False);
      end;
      i := Nodes.Count * (Slices + 1) * 2;
      if ppOutside in Parts then
        Inc(FTriangleCount, i);
      if ppInside in Parts then
        Inc(FTriangleCount, i);
    end;
  end;
  if ppStopDisk in Parts then
  begin
    i := Nodes.Count - 1;
    if SplineMode = lsmCubicSpline then
      normal := posSpline.SplineSlopeVector(Nodes.Count - 1)
    else
      normal := Nodes.Vector(i);
    CalculateRow(@rows[0], PAffineVector(@Nodes[i].AsVector)^, normal,
      TVKPipeNode(Nodes[i]).RadiusFactor);
    rows[0].color := TVKPipeNodes(Nodes)[i].Color.Color;
    if ppOutside in Parts then
    begin
      RenderDisk(@rows[0], Nodes[i].AsVector, normal, False, TexCoordTileS);
      FTriangleCount := FTriangleCount + Slices * 2; //Slices+1;
    end;
    if ppInside in Parts then
    begin
      RenderDisk(@rows[0], Nodes[i].AsVector, VectorNegate(normal), True,
        TexCoordTileS);
      FTriangleCount := FTriangleCount + Slices * 2; //Slices+1;
    end;
  end;
  if SplineMode = lsmCubicSpline then
  begin
    posSpline.Free;
    rSpline.Free;
  end;
end;

// ------------------
// ------------------ TVKExtrusionSolid ------------------
// ------------------

// Assign
//

procedure TVKExtrusionSolid.Assign(Source: TPersistent);
begin
  if Source is TVKExtrusionSolid then
  begin
    FStacks := TVKExtrusionSolid(Source).FStacks;
    FNormals := TVKExtrusionSolid(Source).FNormals;
    FNormalDirection := TVKExtrusionSolid(Source).FNormalDirection;
    FParts := TVKExtrusionSolid(Source).FParts;
  end;
  inherited;
end;

// BuildList
//

procedure TVKExtrusionSolid.BuildList(var rci: TVKRenderContextInfo);
var
  {deltaS,}deltaZ: Single;
  lastNormal: TAffineVector;

  procedure CalcNormal(const Top, Bottom: TAffineVector; var normal:
    TAffineVector);
    { extrusion is in Z direction, so the Z component of the normal vector is
      always zero. }
    {var
      p : TAffineVector;}
  begin
    normal.X := Bottom.Y - Top.Y;
    normal.Y := Top.X - Bottom.X;
    normal.Z := 0;
    NormalizeVector(normal);
    if FHeight < 0 then
      NegateVector(normal);
    (*
    p:=Top; p[2]:=p[2] + FHeight;
    CalcPlaneNormal(top,bottom,p,normal);
    *)
  end;

  procedure BuildStep(ptTop, ptBottom: TAffineVector; invertNormals: Boolean;
    topT, bottomT: Single);
  var
    step: Integer;
    topBase, topNext, bottomBase, bottomNext, normal, normTop, normBottom:
      TAffineVector;
    topTPBase, topTPNext, bottomTPBase, bottomTPNext: TTexPoint;
    ptBuffer: TAffineVector;
    angle: Double;
    dir: TAffineVector;
  begin
    // to invert normals, we just need to flip top & bottom
    if invertNormals then
    begin
      ptBuffer := ptTop;
      ptTop := ptBottom;
      ptBottom := ptBuffer;
    end;
    // generate triangle strip for a level
    // TODO : support for triangle fans (when ptTop or ptBottom is on the Y Axis)
//      topTPBase.S:=0;         bottomTPBase.S:=0;
    topTPBase.T := topT;
    bottomTPBase.T := bottomT;
    topBase := ptTop;
    bottomBase := ptBottom;
    CalcNormal(topBase, bottomBase, normal);
    if (FNormals = nsFlat) then
      lastNormal := normal
    else if (FNormals = nsSmooth) then
    begin
      angle := VectorDotProduct(normal, lastNormal);
      if (angle < FMinSmoothAngleCos) then
      begin
        lastNormal := normal;
      end;
    end;
    if invertNormals then
    begin
      normTop := Normal;
      normBottom := lastnormal;
    end
    else
    begin
      normTop := lastNormal;
      normBottom := normal;
    end;

    dir := VectorNormalize(VectorSubtract(bottomBase, topBase));

    topTPBase.S := VectorDotProduct(topBase, dir);
    topTPBase.T := topBase.Z;
    bottomTPBase.S := VectorDotProduct(bottomBase, dir);
    bottomTPBase.T := bottomBase.Z;

    lastNormal := normal;
    topNext := topBase;
    bottomNext := bottomBase;
    topTPNext := topTPBase;
    bottomTPNext := bottomTPBase;
    glBegin(GL_TRIANGLE_STRIP);
    glNormal3fv(@normTop);
    glTexCoord2fv(@topTPBase);
    glVertex3fv(@topBase);
    for step := 1 to FStacks do
    begin
      glNormal3fv(@normBottom);
      glTexCoord2fv(@bottomTPBase);
      glVertex3fv(@bottomBase);
      topNext.Z := step * DeltaZ;
      bottomNext.Z := topNext.Z;
      topTPNext.T := topNext.Z;
      bottomTPNext.T := bottomNext.Z;
      glTexCoord2fv(@topTPNext);
      glNormal3fv(@normTop);
      glVertex3fv(@topNext);
      topBase := topNext;
      topTPBase := topTPNext;
      bottomBase := bottomNext;
      bottomTPBase := bottomTPNext;
    end;
    glNormal3fv(@normBottom);
    glTexCoord2fv(@bottomTPBase);
    glVertex3fv(@bottomBase);
    glEnd;
  end;

var
  n, i: Integer;
  invertedNormals: Boolean;
  normal: TAffineVector;
begin
  if Outline.Count < 1 then
    Exit;
  deltaZ := FHeight / FStacks;
  //   deltaS:=1/FStacks;
  invertedNormals := (FNormalDirection = ndInside);
  FTriangleCount := 0;
  // generate sides
  if (FHeight <> 0) and ((espInside in FParts) or (espOutside in FParts)) then
  begin
    for n := 0 to Outline.Count - 1 do
    begin
      with Outline.List[n] do
        if count > 1 then
        begin
          if espInside in Parts then
          begin
            CalcNormal(List^[count - 1], List^[0], lastNormal);
            if not InvertedNormals then
              NegateVector(lastNormal);
            for i := 0 to Count - 2 do
            begin
              BuildStep(List^[i], List^[i + 1], not invertedNormals,
                i / (Count - 1), (i + 1) / (Count - 1));
            end;
            BuildStep(List^[count - 1], List^[0], not invertedNormals, 1, 0);
          end;
          if espOutside in Parts then
          begin
            CalcNormal(List^[count - 1], List^[0], lastNormal);
            if InvertedNormals then
              NegateVector(lastNormal);
            for i := 0 to Count - 2 do
            begin
              BuildStep(List^[i], List^[i + 1], invertedNormals,
                i / (Count - 1), (i + 1) / (Count - 1));
            end;
            BuildStep(List^[count - 1], List^[0], invertedNormals, 1, 0);
          end;
        end;
    end;
    glTexCoord2fv(@NullTexPoint);
  end;
  // tessellate start/stop polygons
  if (espStartPolygon in FParts) or (espStopPolygon in FParts) then
  begin
    normal := ContoursNormal;
    // tessellate stop polygon
    if espStopPolygon in FParts then
    begin
      glPushMatrix;
      glTranslatef(0, 0, FHeight);
      RenderTesselatedPolygon(true, @normal, invertedNormals);
      glPopMatrix;
    end;
    // tessellate start polygon
    if espStartPolygon in FParts then
    begin
      NegateVector(normal);
      RenderTesselatedPolygon(true, @normal, not invertedNormals);
    end;
  end;
end;

// Create
//

constructor TVKExtrusionSolid.Create(AOwner: TComponent);
begin
  inherited;
  FHeight := 1;
  FStacks := 1;
  FNormals := nsFlat;
  FNormalDirection := ndOutside;
  FParts := [espOutside];
  MinSmoothAngle := 5;
  FAxisAlignedDimensionsCache.X := -1;
end;

// Destroy
//

destructor TVKExtrusionSolid.Destroy;
begin
  inherited;
end;

// SetHeight
//

procedure TVKExtrusionSolid.SetHeight(const Value: GLfloat);
begin
  if (Value <> FHeight) then
  begin
    FHeight := Value;
    StructureChanged;
  end;
end;

// SetMinSmoothAngle
//

procedure TVKExtrusionSolid.SetMinSmoothAngle(const Value: Single);
var
  s, c: Single;
begin
  FMinSmoothAngle := Value;
  SinCosine(Value * cPidiv180, s, c);
  FMinSmoothAngleCos := c;
end;

// SetNormalDirection
//

procedure TVKExtrusionSolid.SetNormalDirection(const val: TNormalDirection);
begin
  if FNormalDirection <> val then
  begin
    FNormalDirection := val;
    StructureChanged;
  end;
end;

// SetNormals
//

procedure TVKExtrusionSolid.SetNormals(const val: TNormalSmoothing);
begin
  if FNormals <> val then
  begin
    FNormals := val;
    StructureChanged;
  end;
end;

// SetParts
//

procedure TVKExtrusionSolid.SetParts(const val: TExtrusionSolidParts);
begin
  if FParts <> val then
  begin
    FParts := val;
    StructureChanged;
  end;
end;

// SetStacks
//

procedure TVKExtrusionSolid.SetStacks(const val: Integer);
begin
  if (val <> FStacks) and (val > 0) then
  begin
    FStacks := val;
    StructureChanged;
  end;
end;

// AxisAlignedDimensionsUnscaled
//

function TVKExtrusionSolid.AxisAlignedDimensionsUnscaled: TVector;
var
  dMin, dMax: TAffineVector;
begin
  if FAxisAlignedDimensionsCache.X < 0 then
  begin
    Contours.GetExtents(dMin, dMax);
    FAxisAlignedDimensionsCache.X := MaxFloat(Abs(dMin.X), Abs(dMax.X));
    FAxisAlignedDimensionsCache.Y := MaxFloat(Abs(dMin.Y), Abs(dMax.Y));
    FAxisAlignedDimensionsCache.Z := MaxFloat(Abs(dMin.Z), Abs(dMax.Z +
      Height));
  end;
  SetVector(Result, FAxisAlignedDimensionsCache);
end;

// StructureChanged
//

procedure TVKExtrusionSolid.StructureChanged;
begin
  FAxisAlignedDimensionsCache.X := -1;
  inherited;
end;

// ------------------------------------------------------------------
// ------------------------------------------------------------------
// ------------------------------------------------------------------
initialization
  // ------------------------------------------------------------------
  // ------------------------------------------------------------------
  // ------------------------------------------------------------------

   // class registrations
  RegisterClasses([TVKRevolutionSolid, TVKExtrusionSolid, TVKPipe]);

end.

