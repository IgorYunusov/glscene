//
// This unit is part of the DGLEngine Project, http://DGLEngine.org
//
{: DGLStates<p>

      Tools for managing an application-side cache of OpenGL state.<p>

 <b>Historique : </b><font size=-1><ul>
      <li>22/12/15 - JD -  Imported and improved From GLScene
 </ul></font>
}
unit DGLStatesTMP;

interface

{$I DGLEngine.inc}
{.$DEFINE GLS_CACHE_MISS_CHECK}

uses
  System.Classes, System.SysUtils,
  //GLS
  DGLCrossPlatform,
  DGLVectorTypes,
  DGLVectorMaths,
  dglOpenGL,
  DGLTextureFormat,
  GLSLog;

const
  GLS_VERTEX_ATTR_NUM = 16;

type

  TGLStateType = (sttCurrent, sttPoint, sttLine, sttPolygon, sttPolygonStipple,
    sttPixelMode, sttLighting, sttFog, sttDepthBuffer, sttAccumBuffer,
    sttStencilBuffer, sttViewport, sttTransform, sttEnable, sttColorBuffer,
    sttHint, sttEval, sttList, sttTexture, sttScissor,
    sttMultisample);

  TGLStateTypes = set of TGLStateType;

const
  cAllAttribBits = [low(TGLStateType)..High(TGLStateType)];

type

  TGLMeshPrimitive = (
    mpNOPRIMITIVE,
    mpTRIANGLES,
    mpTRIANGLE_STRIP,
    mpTRIANGLE_FAN,
    mpPOINTS,
    mpLINES,
    mpLINE_LOOP,
    mpLINE_STRIP,
    mpLINES_ADJACENCY,
    mpLINE_STRIP_ADJACENCY,
    mpTRIANGLES_ADJACENCY,
    mpTRIANGLE_STRIP_ADJACENCY,
    mpPATCHES
    );

  TGLMeshPrimitives = set of TGLMeshPrimitive;

const
  cAllMeshPrimitive = [
    mpTRIANGLES,
    mpTRIANGLE_STRIP,
    mpTRIANGLE_FAN,
    mpPOINTS,
    mpLINES,
    mpLINE_LOOP,
    mpLINE_STRIP,
    mpLINES_ADJACENCY,
    mpLINE_STRIP_ADJACENCY,
    mpTRIANGLES_ADJACENCY,
    mpTRIANGLE_STRIP_ADJACENCY,
    mpPATCHES];

type

  // TGLState
  //
  //: Reflects all relevant (binary) states of OpenGL subsystem
  TGLState = (stAlphaTest, stBlend, stCullFace, stDepthTest, stDepthClamp,
              stScissorTest, stStencilTest, stIndexLogicOp,
              stDither,
              stColorMaterial, stColorLogicOp, stColorSum,
              stFog, stLighting,
              stNormalize, stAutoNormal, stRescaleNormal,
              stMultisample, stSampleAlphaToCoverage,
              stLineSmooth, stLineStipple,
              stPointSmooth, stPointSprite,
              stPolygonOffsetPoint, stPolygonSmooth, stPolygonStipple, stPolygonOffsetLine,  stPolygonOffsetFill,
              stVertexProgramPointSize, stVertexProgramTwoSide,stNone);

Const
   GLEnumStates: array[stAlphaTest..stNone] of GLEnum =
   (GL_Alpha_Test,GL_Auto_Normal,GL_Blend,GL_Color_Logic_Op,GL_Color_Material,GL_Color_Sum,
    GL_Cull_Face,GL_Depth_Test,GL_Dither,
    GL_Fog,GL_Index_Logic_Op,GL_Lighting,GL_Line_Smooth,GL_Line_Stipple,
    GL_Multisample,GL_Normalize,GL_Point_Smooth,GL_Point_Sprite,GL_Rescale_Normal,
    GL_Sample_Alpha_To_Coverage,GL_Scissor_Test,GL_Stencil_Test,GL_Vertex_Program_Point_Size,
    GL_Vertex_Program_Two_Side,0);

type
  TGLStates = set of TGLState;

  TComparisonFunction = (cfNever, cfAlways, cfLess, cfLEqual, cfEqual,cfGreater, cfNotEqual, cfGEqual);

  TStencilFunction = TComparisonFunction;
  TDepthFunction = TComparisonFunction;

  TBlendFunction = (bfZero, bfOne,
    bfSrcColor, bfOneMinusSrcColor, bfDstColor, bfOneMinusDstColor,
    bfSrcAlpha, bfOneMinusSrcAlpha, bfDstAlpha, bfOneMinusDstAlpha,
    bfConstantColor, bfOneMinusConstantColor,
    bfConstantAlpha, bfOneMinusConstantAlpha,
    bfSrcAlphaSat);

  TDstBlendFunction = bfZero..bfOneMinusConstantAlpha;

  TBlendEquation = (beAdd, beSubtract, beReverseSubtract, beMin, beMax);


  TBlendingMode = (bmOpaque, bmTransparency, bmAdditive, bmAlphaTest50,bmAlphaTest100, bmModulate);

  TFaceMode = (fmPoints, fmLines, fmFill);

  TStencilOp = (soKeep, soZero, soReplace, soIncr, soDecr, soInvert, soIncrWrap,
    soDecrWrap);

  TLogicOp = (loClear, loAnd, loAndReverse, loCopy, loAndInverted, loNoOp,
    loXOr, loOr, loNor, loEquiv, loInvert, loOrReverse, loCopyInverted,
    loOrInverted, loNAnd, loSet);

  TQueryType = (
    qrySamplesPassed,
    qryPrimitivesGenerated,
    qryTransformFeedbackPrimitivesWritten,
    qryTimeElapsed,
    qryAnySamplesPassed);

  // TFaceWinding
  //
//: Describe what kind of winding has a front face
  TFaceWinding = (fwCounterClockWise, fwClockWise);

  TPolygonMode = (pmFill, pmLines, pmPoints);

  TCullFaceMode = (cmFront, cmBack, cmFrontAndBack);
  //  TSingleCullFaceMode = cmFront..cmBack;

  TColorComponent = (ccRed, ccGreen, ccBlue, ccAlpha);
  TColorMask = set of TColorComponent;

const
  cAllColorComponents = [ccRed, ccGreen, ccBlue, ccAlpha];
  MAX_HARDWARE_LIGHT = 16;
  MAX_SHADER_LIGHT = 8;
  MAX_HARDWARE_TEXTURE_UNIT = 48;
  MAX_HARDWARE_UNIFORM_BUFFER_BINDING = 75;

type

  THintType = (hintDontCare, hintFastest, hintNicest);

  TLightSourceStateDef = packed record
    Position: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    Ambient: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    Diffuse: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    Specular: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    SpotDirection: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    SpotCosCutoffExponent: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
    Attenuation: array[0..MAX_HARDWARE_LIGHT-1] of TVector;
  end;

  TShaderLightSourceStateDef = packed record
    Position: array[0..MAX_SHADER_LIGHT-1] of TVector;
    Ambient: array[0..MAX_SHADER_LIGHT-1] of TVector;
    Diffuse: array[0..MAX_SHADER_LIGHT-1] of TVector;
    Specular: array[0..MAX_SHADER_LIGHT-1] of TVector;
    SpotDirection: array[0..MAX_SHADER_LIGHT-1] of TVector;
    SpotCosCutoffExponent: array[0..MAX_SHADER_LIGHT-1] of TVector;
    Attenuation: array[0..MAX_SHADER_LIGHT-1] of TVector;
  end;

  TOnLightsChanged = procedure(Sender: TObject);

  TGLBufferBindingTarget = (bbtUniform, bbtTransformFeedBack);

  TUBOStates = record
    FUniformBufferBinding: TGLuint;
    FOffset: PGLInt;
    FSize: PGLInt;
  end;

  TGLMaterialLevel = (mlAuto, mlFixedFunction, mlMultitexturing, mlSM3, mlSM4, mlSM5);

  //================================================================================================
  // TDGLStateCache
  //
  {: Custom Base class caching OpenGL States.<p>
     Don't using it directly. You must use descendant of this class
   }
  TDGLCustomStateCache = class
  private
  protected
  public
     procedure Reset;virtual;abstract;
     procedure GetStates;virtual;abstract;
     procedure Assign(StateCache: TDGLCustomStateCache);virtual;abstract;
     procedure StoreTo(StateCache: TDGLCustomStateCache);virtual;abstract;
  End;

  TDGLBlendingStateCache = class(TDGLCustomStateCache)
  private
    FChecked: boolean;
  public
    Enabled: boolean;
    SFactor: TGLEnum;
    DFactor: TGLEnum;
    BlendColor: TVector;
    BlendDstAlpha: TGLEnum;
    BlendDstRGB: TGLEnum;
    BlendSrcAlpha: TGLEnum;
    BlendSrcRGB: TGLEnum;
    BlendEquation: TGLEnum;
    BlendEquationAlpha: TGLEnum;
    BlendEquationRGB: TGLEnum;
    procedure Reset;
    procedure Assign(BlendingCache: TDGLBlendingStateCache);
    procedure StoreTo(BlendingCache: TDGLBlendingStateCache);
    procedure GetStates;
  end;

//  TDGLAlphaStateCache = class(TDGLCustomStateCache)
//  private
//    FChecked: boolean;
//  public
//    Enabled: boolean;
//    Func: TGLEnum;
//    Ref: single;
//    procedure Reset;
//    procedure Assign(AlphaCache: TDGLAlphaStateCache);
//    procedure StoreTo(AlphaCache: TDGLAlphaStateCache);
//    procedure GetStates;
//  end;

  TDGLDepthStateCache = class(TDGLCustomStateCache)
  private
    FChecked: boolean;
  public
    DepthMask: boolean;
    DepthFunc: GLEnum;
    DepthRange: GLEnum;
    DepthNear: single;
    DepthFar: single;
    DepthScale: single;
    DepthBias: single;
    DepthBits: integer;
    DepthClearValue: single;
    Enabled: boolean;
    procedure Reset;
    procedure Assign(DepthCache: TDGLDepthStateCache);
    procedure StoreTo(DepthCache: TDGLDepthStateCache);
    procedure GetStates;
  end;

  TDGLTextureStateCache = class(TDGLCustomStateCache)
  private
    FChecked: boolean;



  protected

  public
    Texture1D: boolean;
    Texture2D: boolean;
    Texture3D: boolean;
    TextureCubeMap: boolean;
    TextureRectangle: boolean;
    Units: array of record
       Target: TGLEnum;
       ID: GLUint;
    end;
    CurrentUnit: byte;
    CurrentClientUnit: byte;

    procedure Reset;
    procedure Assign(TextureCache: TDGLTextureStateCache);
    procedure StoreTo(TextureCache: TDGLTextureStateCache);
    procedure GetStates;


  end;

//  TDGLMatrixStateCache = class(TDGLCustomStateCache)
//  private
//    FChecked: boolean;
//  public
//    ModelMatrix: TList;
//    ProjectionMatrix: TList;
//    TextureMatrix: TList;
//    ColorMatrix: TList;
//    MatrixMode: GLEnum;
//    Current: record
//      ModelViewMatrix: TMatrix;
//      MVLoaded: boolean;
//      TextureMatrix: TMatrix;
//      TMLoaded: boolean;
//      ProjectionMatrix: TMatrix;
//      PMLoaded: boolean;
//      ColorMatrix: TMatrix;
//      CMLoaded: boolean;
//    end;
//    constructor Create;
//    destructor Destroy; override;
//    procedure Reset;
//    procedure Assign(ShaderCache: TDGLMatrixStateCache);
//    procedure StoreTo(ShaderCache: TDGLMatrixStateCache);
//    procedure GetStates;
//  end;
//
//  TDGLShaderStateCache =  class(TDGLCustomStateCache)
//  private
//    FShadersStack: array [0..32] of cardinal;
//    FStackTop: integer;
//    procedure Clear;
//  public
//    procedure Push(ShaderId: Cardinal);
//    function Pop: cardinal;
//    function Last: cardinal;
//    constructor Create;
//    procedure Reset;
//    procedure Assign(ShaderCache: TDGLShaderStateCache);
//    procedure StoreTo(ShaderCache: TDGLShaderStateCache);
//    procedure GetStates;
// end;


  TDGLStencilStateCache = class(TDGLCustomStateCache);
  TDGLClipPlanesCache = class(TDGLCustomStateCache);
  TDGLLineStateCache = class(TDGLCustomStateCache);
  TDGLPolygonStateCache = class(TDGLCustomStateCache);

  TDGLMaterialStateCache = class(TDGLCustomStateCache);

  TDGLTextureMapStateCache = class(TDGLCustomStateCache);
  TDGLTextureGenStateCache = class(TDGLCustomStateCache);

  TDGLVertexBufferStateCache = class(TDGLCustomStateCache);
  TDGLFrameBufferStateCache = class(TDGLCustomStateCache);
  TDGLPixelBufferStateCache = class(TDGLCustomStateCache);

  TDGLLightingStateCache = class(TDGLCustomStateCache);



  // TDGLStatesCache
  //
  {: Manages an application-side cache of OpenGL states and parameters.<p>
     Purpose of this class is to eliminate redundant state and parameter
     changes, and there will typically be no more than one state cache per
     OpenGL context. }
  TDGLStatesCache = class
  private
    FChecked: boolean;
    States: set of TGLStates;
    FBlendingCache : TDGLBlendingStateCache;
//    FAlphaCache    : TDGLAlphaStateCache;
    FDepthCache    : TDGLDepthStateCache;
    FTextureCache  : TDGLTextureStateCache;
  protected
  public
    { Public Declarations }
    constructor Create; virtual;
    destructor Destroy; override;

    property Blending : TDGLBlendingStateCache read FBlendingCache write FBlendingCache;
//    property Alpha    : TDGLAlphaStateCache read FAlphaCache write FAlphaCache;
    property Depth    : TDGLDepthStateCache read FDepthCache write FDepthCache;
    property Texture  : TDGLTextureStateCache read FTextureCache write FTextureCache;
  end;


var DGLStatesCache: TDGLStatesCache;

implementation



//------------------------------------------------------------------------------------------------
// Internal helper opengl funcs for setting Cached states

function GetStateByEnum(state: GLEnum):TGLStates;
begin
  for result:=stAlphaTest to stNone do
    if GLEnumStates[result]=state then exit;
  result:=stNone;
end;

function GetTextureStates(state: GLEnum): boolean;
begin
  with DGLStatesCache.Texture do begin
   case state  of
     GL_Texture_1D: result:=Texture1D;
     GL_Texture_2D: result:=Texture2D;
     GL_Texture_3D: result:=Texture3D;
     GL_TEXTURE_CUBE_MAP: result:=TextureCubeMap;
     GL_TEXTURE_RECTANGLE: result:=TextureRectangle;
     else result:=glIsEnabled(state);
   end;
  end;
end;

procedure SetTextureStates(state: GLEnum; value:boolean);
begin
  if GetTextureStates(state)<>Value then
  with DGLStatesCache.Texture do begin
    case state  of
     GL_Texture_1D: Texture1D:=value;
     GL_Texture_2D: Texture2D:=value;
     GL_Texture_3D: Texture3D:=value;
     GL_TEXTURE_CUBE_MAP: TextureCubeMap:=value;
     GL_TEXTURE_RECTANGLE: TextureRectangle:=value;
    end;
    if Value then glEnable(state) else glDisable(state);
  end;
end;

function StateIsEnabled(cap: GLEnum): boolean;
var state: TGLStates;
begin
  state:=GetStateByEnum(cap);
  if state<>stNone then begin
     result:=state in DGLStatesCache.States;
     exit;
  end;
  case cap of
    GL_Texture_1D,GL_Texture_2D,GL_Texture_3D,GL_TEXTURE_CUBE_MAP,
    GL_TEXTURE_RECTANGLE: begin
       result:=GetTextureStates(cap);exit;
    end;
  end;
  result:=glIsEnabled(cap);
end;

procedure EnableState(cap: TGLEnum);
var state: TGLStates;
begin
  state:=GetStateByEnum(cap);
  if state<>stNone then begin
     if not (state in DGLStatesCache.States) then begin
        glEnable(cap);
        DGLStatesCache.States:=DGLStatesCache.States+[state];
        exit;
     end else exit;
  end;
  case cap of
    GL_Texture_1D,GL_Texture_2D,GL_Texture_3D,GL_TEXTURE_CUBE_MAP,
    GL_TEXTURE_RECTANGLE: begin
       SetTextureStates(cap,true);exit;
    end;
  end;
  glEnable(cap);
end;

procedure DisableState(cap: TGLEnum);
var state: TGLStates;
begin
  state:=GetStateByEnum(cap);
  if state<>stNone then begin
     if (state in DGLStatesCache.States) then begin
        glDisable(cap);
        DGLStatesCache.States:=DGLStatesCache.States-[state];
        exit;
     end else exit;
  end;
  case cap of
    GL_Texture_1D,GL_Texture_2D,GL_Texture_3D,GL_TEXTURE_CUBE_MAP,
    GL_TEXTURE_RECTANGLE: begin
       SetTextureStates(cap,false);
       exit;
    end;
  end;
  glDisable(cap);
end;

procedure BindTexture(target: TGLEnum; texture: TGLuint);
begin
  with DGLStatesCache.Texture do
  begin
     if Units[CurrentUnit].ID<>texture then
     begin
        glBindTexture(target,Texture);
        Units[CurrentUnit].Target:=target;
        Units[CurrentUnit].ID:=Texture;
     end;
  end;
end;

procedure ActiveTexture(target: TGLenum);
begin
  if target<>DGLStatesCache.Texture.CurrentUnit+GL_Texture0 then
  begin
    glActiveTexture(target);
    DGLStatesCache.Texture.CurrentUnit:=target-GL_Texture0;
  end;
end;

procedure SetBlendFunc(sfactor: TGLEnum; dfactor: TGLEnum);
begin
  if (DGLStatesCache.Blending.SFactor<>sfactor)
  or (DGLStatesCache.Blending.DFactor<>dfactor) then
  begin
    glBlendFunc(sfactor, dfactor);
    DGLStatesCache.Blending.SFactor:=sfactor;
    DGLStatesCache.Blending.DFactor:=dfactor;
  end;
end;

procedure SetBlendColor(red, green, blue, alpha: TGLclampf);
begin
  if not VectorEquals(DGLStatesCache.Blending.BlendColor,vectormake(red, green, blue, alpha)) then
  begin
    glBlendColor(red, green, blue, alpha);
    DGLStatesCache.Blending.BlendColor:=vectormake(red, green, blue, alpha);
  end;
end;

procedure SetBlendEquation(mode: TGLEnum);
begin
  if DGLStatesCache.Blending.BlendEquation <> mode then
  begin
    glBlendEquation(mode);
    DGLStatesCache.Blending.BlendEquation:=mode;
  end;
end;

procedure SetBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha: TGLenum);
begin
  if (DGLStatesCache.Blending.BlendSrcRGB<>sfactorRGB)
  or (DGLStatesCache.Blending.BlendDstRGB<>dfactorRGB)
  or (DGLStatesCache.Blending.BlendSrcAlpha<>sfactorAlpha)
  or (DGLStatesCache.Blending.BlendDstAlpha<>dfactorAlpha) then
  begin
    glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    DGLStatesCache.Blending.BlendSrcRGB:=sfactorRGB;
    DGLStatesCache.Blending.BlendDstRGB:=dfactorRGB;
    DGLStatesCache.Blending.BlendSrcAlpha:=sfactorAlpha;
    DGLStatesCache.Blending.BlendDstAlpha:=dfactorAlpha;
  end;
end;

procedure SetBlendEquationSeparate(modeRGB: TGLenum; modeAlpha: TGLenum);
begin
  if (DGLStatesCache.Blending.BlendEquationRGB <> modeRGB)
  or (DGLStatesCache.Blending.BlendEquationAlpha <> modeAlpha) then
  begin
    glBlendEquationSeparate(modeRGB, modeAlpha);
    DGLStatesCache.Blending.BlendEquationRGB := modeRGB;
    DGLStatesCache.Blending.BlendEquationAlpha := modeAlpha;
  end;
end;

//procedure SetAlphaFunc(func: TGLEnum; ref: TGLclampf);
//begin
//  if (DGLStatesCache.Alpha.Func<>func)
//  or (DGLStatesCache.Alpha.Ref<>ref)
//  then begin
//    glAlphaFunc(func, ref);
//    DGLStatesCache.Alpha.Func:=func;
//    DGLStatesCache.Alpha.Ref:=ref;
//  end;
//end;



//------------------------------------------------------------------------------------------------

//================================================================================================
// TDGLBlendingCache
//
procedure TDGLBlendingStateCache.Assign(BlendingCache: TDGLBlendingStateCache);
begin
  if BlendingCache.Enabled then glEnable(GL_BLEND)
  else glDisable(GL_BLEND);

  SetBlendColor(BlendingCache.BlendColor[0],
               BlendingCache.BlendColor[1],
               BlendingCache.BlendColor[2],
               BlendingCache.BlendColor[3]);

  SetBlendEquationSeparate(BlendingCache.BlendEquationRGB,BlendingCache.BlendEquationAlpha);
  SetBlendFuncSeparate(BlendingCache.BlendSrcRGB,BlendingCache.BlendDstRGB,
                      BlendingCache.BlendSrcAlpha,BlendingCache.BlendDstAlpha);

  SetBlendEquation(BlendingCache.BlendEquation);
  SetBlendFunc(BlendingCache.SFactor, BlendingCache.DFactor);

  FChecked:=true;
end;

procedure TDGLBlendingStateCache.GetStates;
begin
  Enabled:=glisEnabled(GL_BLEND);
  if Enabled then DGLStatesCache.States:=DGLStatesCache.States+[stBlend];

  glGetIntegerv(GL_BLEND_SRC,@SFactor);
  glGetIntegerv(GL_BLEND_DST,@DFactor);
  glGetFloatv(GL_BLEND_COLOR,@BlendColor);
  glGetIntegerv(GL_BLEND_DST_ALPHA,@BlendDstAlpha);
  glGetIntegerv(GL_BLEND_DST_RGB,@BlendDstRGB);
  glGetIntegerv(GL_BLEND_SRC_ALPHA,@BlendSRCAlpha);
  glGetIntegerv(GL_BLEND_SRC_RGB,@BlendSRCRGB);
  glGetIntegerv(GL_BLEND_EQUATION_ALPHA,@BlendEquationAlpha);
  glGetIntegerv(GL_BLEND_EQUATION_RGB,@BlendEquationRGB);
  glGetIntegerv(GL_BLEND_EQUATION,@BlendEquation);
  FChecked:=true;
end;

procedure TDGLBlendingStateCache.Reset;
begin
  glDisable(GL_BLEND);
  Enabled:=false;
  DGLStatesCache.States:=DGLStatesCache.States-[stBlend];
  SetBlendColor(0,0,0,0);
  SetBlendEquationSeparate(GL_FUNC_ADD,GL_FUNC_ADD);
  SetBlendFuncSeparate(GL_ONE,GL_ZERO,GL_ONE,GL_ZERO);
  SetBlendEquation(GL_FUNC_ADD);
  SetBlendFunc(GL_ONE, GL_ZERO);
  FChecked:=true;
end;

procedure TDGLBlendingStateCache.StoreTo(BlendingCache: TDGLBlendingStateCache);
begin
  BlendingCache.FChecked:=FChecked;
  BlendingCache.Enabled:=Enabled;
  BlendingCache.SFactor:=SFactor;
  BlendingCache.DFactor:=DFactor;
  BlendingCache.BlendColor:=BlendColor;
  BlendingCache.BlendDstAlpha:=BlendDstAlpha;
  BlendingCache.BlendDstRGB:=BlendDstRGB;
  BlendingCache.BlendSrcAlpha:=BlendSrcAlpha;
  BlendingCache.BlendSrcRGB:=BlendSrcRGB;
  BlendingCache.BlendEquation:=BlendEquation;
  BlendingCache.BlendEquationAlpha:=BlendEquationAlpha;
  BlendingCache.BlendEquationRGB:=BlendEquationRGB;
end;

//================================================================================================
// TDGLAlphaStateCache
//

//procedure TDGLAlphaStateCache.Assign(AlphaCache: TDGLAlphaStateCache);
//begin
//  if AlphaCache.Enabled then EnableState(GL_ALPHA_TEST)
//  else DisableState(GL_ALPHA_TEST);
//  glAlphaFunc(AlphaCache.Func, AlphaCache.Ref);
//  FChecked:=true;
//end;
//
//procedure TDGLAlphaStateCache.GetStates;
//begin
//  Enabled:=glisEnabled(GL_ALPHA_TEST);
//  if Enabled then DGLStatesCache.States:=DGLStatesCache.States+[stAlphaTest];
//  glGetIntegerv(GL_ALPHA_TEST_FUNC,@Func);
//  glGetFloatv(GL_ALPHA_TEST_REF,@Ref);
//  FChecked:=true;
//end;
//
//procedure TDGLAlphaStateCache.Reset;
//begin
//  DisableState(GL_ALPHA_TEST);
//  DGLStatesCache.States:=DGLStatesCache.States-[stAlphaTest];
//  SetAlphaFunc(GL_ALWAYS, 0);
//  FChecked:=true;
//end;


//procedure TDGLAlphaStateCache.StoreTo(AlphaCache: TDGLAlphaStateCache);
//begin
//  AlphaCache.FChecked:=FChecked;
//  AlphaCache.Enabled:=Enabled;
//  AlphaCache.Func:=Func;
//  AlphaCache.Ref:=Ref;
//end;


//================================================================================================
// TDGLDepthStateCache
//
procedure TDGLDepthStateCache.Assign(DepthCache: TDGLDepthStateCache);
begin
   FChecked:=DepthCache.FChecked;
   if DepthCache.Enabled then glEnable(GL_DEPTH_TEST)
   else glDisable(GL_DEPTH_TEST);
   glDepthMask(DepthCache.DepthMask);
   glDepthFunc(DepthCache.DepthFunc);
   glDepthRange(DepthCache.DepthNear,DepthCache.DepthFar);
   glGetIntegerv(GL_DEPTH_RANGE, @DepthRange);

//   glPixelTransferf(GL_DEPTH_SCALE,DepthCache.DepthScale); --> DEPRECATED
//   glPixelTransferf(GL_DEPTH_BIAS,DepthCache.DepthBias);

   glClearDepth(DepthCache.DepthClearValue);
   DepthBits:=DepthCache.DepthBits;
end;

procedure TDGLDepthStateCache.GetStates;
begin
  Enabled:=glisEnabled(GL_DEPTH_TEST);
  if Enabled then DGLStatesCache.States:=DGLStatesCache.States+[stDepthTest];
  glGetIntegerv(GL_DEPTH_WRITEMASK, @DepthMask);
  glGetIntegerv(GL_DEPTH_FUNC, @DepthFunc);
  glGetIntegerv(GL_DEPTH_RANGE, @DepthRange);

  //glGetFloatv(GL_DEPTH_SCALE, @DepthScale); --> DEPRECATED
  //glGetFloatv(GL_DEPTH_BIAS, @DepthBias);

  glGetFloatv(GL_DEPTH_CLEAR_VALUE, @DepthClearValue);

  //glGetIntegerv(GL_DEPTH_BITS, @DepthBits); --> DEPRECATED
  FChecked:=true;
end;

procedure TDGLDepthStateCache.Reset;
begin
  glDisable(GL_DEPTH_TEST);
  glDepthMask(DepthMask);
  glDepthFunc(GL_LESS);
  glDepthRange(0,1);
  //glPixelTransferf(GL_DEPTH_SCALE,1); --> DEPRECATED
  //glPixelTransferf(GL_DEPTH_BIAS,0);
  glClearDepth(1);
  DepthNear:=0;
  DepthFar:=1;
  DepthBits:=24;
  FChecked:=true;
end;

procedure TDGLDepthStateCache.StoreTo(DepthCache: TDGLDepthStateCache);
begin
  DepthCache.FChecked:=FChecked;
  DepthCache.DepthMask:=DepthMask;
  DepthCache.DepthFunc:=DepthFunc;
  DepthCache.DepthRange:=DepthRange;
  DepthCache.DepthNear:=DepthNear;
  DepthCache.DepthFar:=DepthFar;
  DepthCache.DepthScale:=DepthScale;
  DepthCache.DepthBias:=DepthBias;
  DepthCache.DepthBits:=DepthBits;
  DepthCache.DepthClearValue:=DepthClearValue;
  DepthCache.Enabled:=Enabled;
end;

//================================================================================================
// TDGLTextureStateCache
//




procedure TDGLTextureStateCache.Assign(TextureCache: TDGLTextureStateCache);
var i:integer;
begin
  ActiveTexture(TextureCache.CurrentUnit+GL_TEXTURE0);

  if TextureCache.Texture1D then EnableState(GL_TEXTURE_1D)
  else DisableState(GL_TEXTURE_1D);

  if TextureCache.Texture2D then EnableState(GL_TEXTURE_2D)
  else DisableState(GL_TEXTURE_2D);

  if TextureCache.Texture3D then EnableState(GL_TEXTURE_3D)
  else DisableState(GL_TEXTURE_3D);

  if TextureCache.TextureCubeMap then EnableState(GL_TEXTURE_CUBE_MAP)
  else DisableState(GL_TEXTURE_CUBE_MAP);

  if TextureCache.TextureRectangle then EnableState(GL_TEXTURE_RECTANGLE)
  else DisableState(GL_TEXTURE_RECTANGLE);

  BindTexture(TextureCache.Units[CurrentUnit].Target,TextureCache.Units[CurrentUnit].ID);
  ActiveTexture(TextureCache.CurrentClientUnit+GL_TEXTURE0);
  for i:=0 to high(TextureCache.Units) do Units[i]:=TextureCache.Units[i];
end;

procedure TDGLTextureStateCache.GetStates;
var maxTU, ctu, i: integer;
begin
  glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB,@MaxTU);
  setlength(Units,MaxTU);
  if glIsEnabled(GL_TEXTURE_1D) then Texture1D:=true else Texture1D:=false;
  if glIsEnabled(GL_TEXTURE_2D) then Texture2D:=true else Texture2D:=false;
  if glIsEnabled(GL_TEXTURE_3D) then Texture3D:=true else Texture3D:=false;
  if glIsEnabled(GL_TEXTURE_CUBE_MAP) then TextureCubeMap:=true else TextureCubeMap:=false;
  if glIsEnabled(GL_TEXTURE_RECTANGLE) then TextureRectangle:=true else TextureRectangle:=false;
  glGetIntegerv(GL_ACTIVE_TEXTURE,@CTU);
  CurrentUnit:=CTU-GL_TEXTURE0;
  glGetIntegerv(GL_CLIENT_ACTIVE_TEXTURE_ARB,@CTU);
  CurrentClientUnit:=CTU-GL_TEXTURE0;
  for i:=0 to maxTU-1 do begin
     Units[i].Target:=GL_TEXTURE_2D;
     Units[i].ID:=0;
  end;
  FChecked:=true;
end;

procedure TDGLTextureStateCache.Reset;
begin
  FChecked:=true;
  DisableState(GL_TEXTURE_2D);
  DisableState(GL_TEXTURE_3D);
  DisableState(GL_TEXTURE_1D);
  DisableState(GL_TEXTURE_RECTANGLE);
  DisableState(GL_TEXTURE_CUBE_MAP);
  ActiveTexture(GL_TEXTURE0);
  BindTexture(GL_TEXTURE_2D,0);
  ActiveTexture(GL_TEXTURE0);
  BindTexture(GL_TEXTURE_2D,0);
  CurrentUnit:=0;
  CurrentClientUnit:=0;
end;

procedure TDGLTextureStateCache.StoreTo(TextureCache: TDGLTextureStateCache);
var i:integer;
begin
   TextureCache.FChecked:=FChecked;
   TextureCache.Texture1D:=Texture1D;
   TextureCache.Texture2D:=Texture2D;
   TextureCache.Texture3D:=Texture3D;
   TextureCache.TextureCubeMap:=TextureCubeMap;
   TextureCache.TextureRectangle:=TextureRectangle;
   setlength(TextureCache.Units,high(Units)+1);
   for i:=0 to high(Units) do begin
     TextureCache.Units[i].Target:=Units[i].Target;
     TextureCache.Units[i].ID:=Units[i].ID;
   end;
   TextureCache.CurrentUnit:=CurrentUnit;
   TextureCache.CurrentClientUnit:=CurrentClientUnit;
end;

//================================================================================================
// TDGLCustomState
//
constructor TDGLCustomStates.Create;
begin
  inherited;
  // Do Nothing;
end;

destructor TDGLCustomStates.Destroy;
begin
  inherited;
  // Do Nothing;
end;

//================================================================================================
// TDGLBlendState
//
constructor TDGLBlendingStates.Create;
begin
  inherited;
  // Do Nothing;
end;

destructor TDGLBlendingStates.Destroy;
begin
  inherited;
  Reset;
  // Do Nothing;
end;

procedure TDGLBlendingStates.LoadPreset(BlendingMode: TBlendingMode);
begin
  Reset;
  case BlendingMode of
    bmOpaque:
      begin
        FBlendEnable:=false;
        FAlphaTestEnable:=false;
      end;
    bmTransparency:
      begin
        FBlendEnable:=True;
        FAlphaTestEnable:=True;
        FSrcBlendFunc:=GL_SRC_ALPHA;
        FDstBlendFunc:=GL_ONE_MINUS_SRC_ALPHA;
        FAlphaFunc:=GL_GREATER;
        FAlphaThreshold:=0;
      end;
    bmAdditive:
      begin
        FBlendEnable:=True;
        FAlphaTestEnable:=True;
        FSrcBlendFunc:=GL_SRC_ALPHA;
        FDstBlendFunc:=GL_ONE;
        FAlphaFunc:=GL_GREATER;
        FAlphaThreshold:=0;
      end;
    bmAlphaTest50:
      begin
        FBlendEnable:=False;
        FAlphaTestEnable:=True;
        FAlphaFunc:=GL_GEQUAL;
        FAlphaThreshold:=0.5;
      end;
    bmAlphaTest100:
      begin
        FBlendEnable:=False;
        FAlphaTestEnable:=True;
        FAlphaFunc:=GL_GEQUAL;
        FAlphaThreshold:=1;
      end;
    bmModulate:
      begin
        FBlendEnable:=True;
        FAlphaTestEnable:=True;
        FSrcBlendFunc:=GL_DST_COLOR;
        FDstBlendFunc:=GL_ZERO;
        FAlphaFunc:=GL_GREATER;
        FAlphaThreshold:=0;
      end;
  end;
end;

procedure TDGLBlendingStates.Reset;
begin
  FBlendEnable:=false;
  FAlphaTestEnable:=false;
  FSrcBlendFunc:=GL_ONE;
  FDstBlendFunc:=GL_ZERO;
  FAlphaFunc:=GL_ALWAYS;
  FAlphaThreshold:=0;
end;

procedure TDGLBlendingStates.unApply;
begin
  DGLStatesCache.Blending.Reset;
  DGLStatesCache.Alpha.Reset;
end;


//================================================================================================

end.
